[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "First Week of MicroP’s\n\n\nMy thoughts after week 1 of MicroP’s\n\n\n\n\n\nSep 4, 2025\n\n\nMatthew Molinar\n\n\n\n\n\n\n\n\n\n\n\n\nInitial Reflections Post\n\n\nWelcome to my Quarto portfolio\n\n\n\n\n\nAug 27, 2025\n\n\nMatthew Molinar\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Matthew Molinar is an Engineering student at Harvey Mudd College. His interests are in the field of electrical engineering, with a particular focus on RF and digital signal processing."
  },
  {
    "objectID": "posts/second-post.html",
    "href": "posts/second-post.html",
    "title": "First Week of MicroP’s",
    "section": "",
    "text": "I think lab 1 took me a lot longer that I anticipated. Soldering was definitely a time suck and I also hadn’t touched system verilog in so long. That being said, I think the first lab was a good way to revist the system verilog and practice writing a lab report. I’m hoping that lab 2 will be a much smoother sail after having done lab 1. Going into lab 2, I will make sure to start with testbenches before going to hardware. I think this would be a good way to verify that my design works and help save a lot of time debugging."
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "In this lab, we learned how to use time multiplexing to make efficient used of the I/O pins on our FPGA. We used time multiplexing to drive two seven-segment displays with a single set of FPGA I/O pins. We also built transistor circuits to drive large currents from FPGA pins.\n\n\n\n\n\nThis design consists of four lower level modules, which use time multiplexing to control two seven-segment displays with two four-bit switch inputs. Additionally, the switch inputs are added together and their sum is displayed on five LEDs (off-board) to represent a five-bit binary number.\nThe clock division was achieved by using the on-board high-speed oscillator (HSOSC), which generated a 24 MHz clock signal. Then, a counter was used to divide this frequency down to ~60 Hz. After each clock cycle, the seven-segment displays were toggled. Thus, I divided down to a 60 Hz display rate, since it would be fast enough to appear continuous/smooth to the human eye.\nThe switch mux was responsible for selecting the right set of switch inputs based on the enable signal (seven_seg_en), to drive the correct seven segment display. The display_gate module also used the enable signal, but tpo determine which display to turn on.\nFinally, the seven_seg module took in a four-bit switch input and determined the correct seven-segment encoding to diplay the appropraiet hex digit. The input_sum module diplayed the sum of both four-bit switch inputs as a five-bit binary number on five LEDs.\n\n\n\nTesting this design was done via simulation and hardware verification.\nFirst all lower level modules were tested on their own to make sure all possible inputs worked. Then, for simulation of the top module, different clock divider logic was used because the Questa simulator can’t interpret HSOSC. Thus, this simulation ensured the correct toggling of the seven-segment enable signal, correct multiplexing of switch inputs, accurate seven-segment encodings, and correct sum results from switch input addition. The top module only tested a few cases, since every case was exhausted in the lower level module testbenches.\n\n\n\n\nThe source code for the project can be found in the associated GitHub repository.\n\n\n(Figure 1: Block Diagram of the Verilog Design)\nThe block diagram in Figure 1 demonstrates the overall architecture of the design. The top-level module, top, includes four submodules: the switch mux module (switch_mux), the display gate module (display_gate), the seven segment display module (seven_seg), and the input sum module (input_sum). It also contains logic for the the clock divider which toggles the seven_segment displays at our desired frequency (~60 Hz).\n\n\n\n(Figure 2: Schematic of physical layout)\nFigure 2 shows the physical layout of the design. The anodes of seven-segment display were connected using 330 Ω current-limmiting resistors and a 2N3906 PNP transitor to ensure the output current was less than 8 mA. The LEDs of the seven-segment display were connected using 1k Ω resitors, and the off-board LEDs displaying the sum of the switch inputs were connected using 560 Ω resistors.\n\n\n\nAccording, to the ice40 datasheet, on section 4.17 it says the I/O pins are rated for 8 mA. Thus, I chose 330 Ω resistos for the transistor circuit based on the following calculations:\n\\[\nV = 3.3 - V_f = 3.3 - 0.7 = 2.6 \\, \\text{V}\n\\]\n\\[\nV = IR \\quad \\Rightarrow \\quad R = \\frac{V}{I} = \\frac{2.6}{0.008} = 325 \\, \\Omega\n\\]\nFor the seven-segment display LEDs, I used 1 kΩ resistors based on the following equation:\n\\[\nV = 3.3 - V_f = 3.3 - 2 = 1.3 \\, \\text{V}\n\\]\nI didn’t want the LEDs on the display to run too hot or be too bright, so I just used 1 kΩ resistors resulting in a current of 1.3 mA. Finally, I used 560 Ω resisots for the off-board LEDs based on the following equations:\n\\[\nV = 3.3 - V_f = 3.3 - 1.7 = 1.6 \\, \\text{V}\n\\]\n\\[\nV = IR \\quad \\Rightarrow \\quad R = \\frac{V}{I} = \\frac{1.6}{0.02} = 80 \\, \\Omega\n\\]\n\n\n\n\n\n\n(Figure 3: A screenshot of a QuestaSim simulation demonstrating both seven-segment displays toggle appropriately.)\n(Figure 4: A zoomed in screenshot of a QuestaSim simulation demonstrating the both four-bit inputs sum accurately.)\n(Figure 5: A zoomed out screenshot of a QuestaSim simulation demonstrating the both four-bit inputs sum accurately.)\n(Figure 6: A zoomed in screenshot of a QuestaSim simulation demonstrating accurate switching between both four-bit inputs.)\n(Figure 7: A zoomed out screenshot of a QuestaSim simulation demonstrating accurate switching between both four-bit inputs.)\n(Figure 8: A screenshot of a QuestaSim simulation demonstrating that all sub-module work together accurately to implement time multiplexing for a dual seven-segment display.)\nThe design met all intended design objectives. Figure 3 shows that the display_gate module works and that both seven segment displays turn on appropriately. Figures 4 and 5 show that the input_sum module works as intended, and that the correct sum is calculated by adding both four-bit switch inputs. Figures 6 and 7 show that the switch_mux module works and that it can switch between different four-bit inputs accurately. Finally, Figure 8 shows that the top module works as intended and that it accurately merges all sub-modules.\n\n\n\nHardware was also tested to ensure that there was no noticible flickering, both sets of switch inputs could drive separate seven-segment displays without bleeding, and to ensure that LEDs lit up appropriately to display the sum of the inputs as a five-bit binary number.\n\n\n\n\nThe design succesfully implemented time multiplexing to drive two seven-segment displays with a single set of FPGA I/O pins. There was no flickering or bleeding from the dual seven-segment display. I spent a total of 15 hours on this lab.\n\n\n\nFor the following AI Prototype, I will be using ChatGPT.\n\n\nWrite SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits. Use the seven segment decoder and oscillator provided in the attached files.\n\n\n\nmodule two_digit_display (\n    input  logic       clk,        // main clock input\n    input  logic [3:0] in0,        // first 4-bit input\n    input  logic [3:0] in1,        // second 4-bit input\n    output logic [6:0] seg,        // seven segment outputs (shared)\n    output logic [1:0] an          // common anode control (active low if common anode)\n);\n\n    // Internal signals\n    logic mux_sel;        // toggles between digits\n    logic [3:0] nibble;   // selected input bits\n    logic slow_clk;       // divided clock from oscillator\n\n    // Instantiate oscillator / clock divider (from led_control.sv)\n    oscillator u_divider (\n        .clk_in (clk),\n        .clk_out(slow_clk)\n    );\n\n    // Toggle mux_sel on slow clock\n    always_ff @(posedge slow_clk) begin\n        mux_sel &lt;= ~mux_sel;\n    end\n\n    // Select between input sets\n    always_comb begin\n        if (mux_sel == 1'b0) begin\n            nibble = in0;\n            an     = 2'b10;  // enable digit0, disable digit1\n        end else begin\n            nibble = in1;\n            an     = 2'b01;  // enable digit1, disable digit0\n        end\n    end\n\n    // Instantiate seven segment decoder (from seven_seg.sv)\n    seven_seg u_decoder (\n        .bin  (nibble),\n        .seg  (seg)\n    );\n\nendmodule\n\n\n\nI provided my seven_seg and led_control modules from lab 1 and it synthesized first try. I think the quality of the output is really high because it produced very clean and readable code. I was mostly able to follow the code that was generated, however, it used weird variable names such as nibble, which I didn’t understand. The way that it grabbed the oscillator from my led_control module was also weird. I think the code synthesized first try largely due to the prompt and supporting files that it was fed. Thus, when using LLMs in my workflow I will make sure to be as descriptive with prompts as possible, so that it can generate code with behavior that I expect. Next time however, I will make sure to ask about anything in the code that doesn’t make sense to me."
  },
  {
    "objectID": "labs/lab2/lab2.html#lab-2-multiplexed-7-segment-display",
    "href": "labs/lab2/lab2.html#lab-2-multiplexed-7-segment-display",
    "title": "E155 Portfolio",
    "section": "",
    "text": "In this lab, we learned how to use time multiplexing to make efficient used of the I/O pins on our FPGA. We used time multiplexing to drive two seven-segment displays with a single set of FPGA I/O pins. We also built transistor circuits to drive large currents from FPGA pins.\n\n\n\n\n\nThis design consists of four lower level modules, which use time multiplexing to control two seven-segment displays with two four-bit switch inputs. Additionally, the switch inputs are added together and their sum is displayed on five LEDs (off-board) to represent a five-bit binary number.\nThe clock division was achieved by using the on-board high-speed oscillator (HSOSC), which generated a 24 MHz clock signal. Then, a counter was used to divide this frequency down to ~60 Hz. After each clock cycle, the seven-segment displays were toggled. Thus, I divided down to a 60 Hz display rate, since it would be fast enough to appear continuous/smooth to the human eye.\nThe switch mux was responsible for selecting the right set of switch inputs based on the enable signal (seven_seg_en), to drive the correct seven segment display. The display_gate module also used the enable signal, but tpo determine which display to turn on.\nFinally, the seven_seg module took in a four-bit switch input and determined the correct seven-segment encoding to diplay the appropraiet hex digit. The input_sum module diplayed the sum of both four-bit switch inputs as a five-bit binary number on five LEDs.\n\n\n\nTesting this design was done via simulation and hardware verification.\nFirst all lower level modules were tested on their own to make sure all possible inputs worked. Then, for simulation of the top module, different clock divider logic was used because the Questa simulator can’t interpret HSOSC. Thus, this simulation ensured the correct toggling of the seven-segment enable signal, correct multiplexing of switch inputs, accurate seven-segment encodings, and correct sum results from switch input addition. The top module only tested a few cases, since every case was exhausted in the lower level module testbenches.\n\n\n\n\nThe source code for the project can be found in the associated GitHub repository.\n\n\n(Figure 1: Block Diagram of the Verilog Design)\nThe block diagram in Figure 1 demonstrates the overall architecture of the design. The top-level module, top, includes four submodules: the switch mux module (switch_mux), the display gate module (display_gate), the seven segment display module (seven_seg), and the input sum module (input_sum). It also contains logic for the the clock divider which toggles the seven_segment displays at our desired frequency (~60 Hz).\n\n\n\n(Figure 2: Schematic of physical layout)\nFigure 2 shows the physical layout of the design. The anodes of seven-segment display were connected using 330 Ω current-limmiting resistors and a 2N3906 PNP transitor to ensure the output current was less than 8 mA. The LEDs of the seven-segment display were connected using 1k Ω resitors, and the off-board LEDs displaying the sum of the switch inputs were connected using 560 Ω resistors.\n\n\n\nAccording, to the ice40 datasheet, on section 4.17 it says the I/O pins are rated for 8 mA. Thus, I chose 330 Ω resistos for the transistor circuit based on the following calculations:\n\\[\nV = 3.3 - V_f = 3.3 - 0.7 = 2.6 \\, \\text{V}\n\\]\n\\[\nV = IR \\quad \\Rightarrow \\quad R = \\frac{V}{I} = \\frac{2.6}{0.008} = 325 \\, \\Omega\n\\]\nFor the seven-segment display LEDs, I used 1 kΩ resistors based on the following equation:\n\\[\nV = 3.3 - V_f = 3.3 - 2 = 1.3 \\, \\text{V}\n\\]\nI didn’t want the LEDs on the display to run too hot or be too bright, so I just used 1 kΩ resistors resulting in a current of 1.3 mA. Finally, I used 560 Ω resisots for the off-board LEDs based on the following equations:\n\\[\nV = 3.3 - V_f = 3.3 - 1.7 = 1.6 \\, \\text{V}\n\\]\n\\[\nV = IR \\quad \\Rightarrow \\quad R = \\frac{V}{I} = \\frac{1.6}{0.02} = 80 \\, \\Omega\n\\]\n\n\n\n\n\n\n(Figure 3: A screenshot of a QuestaSim simulation demonstrating both seven-segment displays toggle appropriately.)\n(Figure 4: A zoomed in screenshot of a QuestaSim simulation demonstrating the both four-bit inputs sum accurately.)\n(Figure 5: A zoomed out screenshot of a QuestaSim simulation demonstrating the both four-bit inputs sum accurately.)\n(Figure 6: A zoomed in screenshot of a QuestaSim simulation demonstrating accurate switching between both four-bit inputs.)\n(Figure 7: A zoomed out screenshot of a QuestaSim simulation demonstrating accurate switching between both four-bit inputs.)\n(Figure 8: A screenshot of a QuestaSim simulation demonstrating that all sub-module work together accurately to implement time multiplexing for a dual seven-segment display.)\nThe design met all intended design objectives. Figure 3 shows that the display_gate module works and that both seven segment displays turn on appropriately. Figures 4 and 5 show that the input_sum module works as intended, and that the correct sum is calculated by adding both four-bit switch inputs. Figures 6 and 7 show that the switch_mux module works and that it can switch between different four-bit inputs accurately. Finally, Figure 8 shows that the top module works as intended and that it accurately merges all sub-modules.\n\n\n\nHardware was also tested to ensure that there was no noticible flickering, both sets of switch inputs could drive separate seven-segment displays without bleeding, and to ensure that LEDs lit up appropriately to display the sum of the inputs as a five-bit binary number.\n\n\n\n\nThe design succesfully implemented time multiplexing to drive two seven-segment displays with a single set of FPGA I/O pins. There was no flickering or bleeding from the dual seven-segment display. I spent a total of 15 hours on this lab.\n\n\n\nFor the following AI Prototype, I will be using ChatGPT.\n\n\nWrite SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits. Use the seven segment decoder and oscillator provided in the attached files.\n\n\n\nmodule two_digit_display (\n    input  logic       clk,        // main clock input\n    input  logic [3:0] in0,        // first 4-bit input\n    input  logic [3:0] in1,        // second 4-bit input\n    output logic [6:0] seg,        // seven segment outputs (shared)\n    output logic [1:0] an          // common anode control (active low if common anode)\n);\n\n    // Internal signals\n    logic mux_sel;        // toggles between digits\n    logic [3:0] nibble;   // selected input bits\n    logic slow_clk;       // divided clock from oscillator\n\n    // Instantiate oscillator / clock divider (from led_control.sv)\n    oscillator u_divider (\n        .clk_in (clk),\n        .clk_out(slow_clk)\n    );\n\n    // Toggle mux_sel on slow clock\n    always_ff @(posedge slow_clk) begin\n        mux_sel &lt;= ~mux_sel;\n    end\n\n    // Select between input sets\n    always_comb begin\n        if (mux_sel == 1'b0) begin\n            nibble = in0;\n            an     = 2'b10;  // enable digit0, disable digit1\n        end else begin\n            nibble = in1;\n            an     = 2'b01;  // enable digit1, disable digit0\n        end\n    end\n\n    // Instantiate seven segment decoder (from seven_seg.sv)\n    seven_seg u_decoder (\n        .bin  (nibble),\n        .seg  (seg)\n    );\n\nendmodule\n\n\n\nI provided my seven_seg and led_control modules from lab 1 and it synthesized first try. I think the quality of the output is really high because it produced very clean and readable code. I was mostly able to follow the code that was generated, however, it used weird variable names such as nibble, which I didn’t understand. The way that it grabbed the oscillator from my led_control module was also weird. I think the code synthesized first try largely due to the prompt and supporting files that it was fed. Thus, when using LLMs in my workflow I will make sure to be as descriptive with prompts as possible, so that it can generate code with behavior that I expect. Next time however, I will make sure to ask about anything in the code that doesn’t make sense to me."
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "In this lab, a design was implemented on the FPGA to demonstrate the functionality of the on-board high-speed oscillator by blinking one of the on-board LEDs. The high speed oscillator was configured at a frequency of 48 MHz and divided down using a counter to achieve a blinking frequency of 2.4 Hz.\nFurthermore, this design used 4 switches as inputs. These switches turned on an on-board LED by acting as a XOR gate and turned on another on-board LED by acting as an AND gate.\nFinally, this design used the same four switches, acting as a four bit binary number, to turn on a seven-segment display to show all hex digits from 0 to F.\n\n\n\nThis design consists of two lower level modules, which control a seven segment display and on-board LEDs. Both of these modules were called within a top level module.\nThe seven-segment module uses a case statemnt to map 4 bit hex digit inputs to its corresponding seven-segment output. As a result, flipping switches s[3:0] would display the correct hex digits ranging from 0 to F. Although, I wasn’t able to verify this module with testbenches, I was able to verify that it functioned as expected by visually confirming correct hex digit representation using hardware.\nThe LED control module was used to blink on-board LEDs. First, the on-board high speed oscillator (HSOSC) was used to generate a 48 MHz signal. Then, a counter set to 20 million was used to divide the clock signal. As a result, led[2] was toggled on and off at a frequency of 2.4 Hz. The other two LEDs were toggled using switches s[3:0]. The first led, led[0], was turned on by the XOR of s[0] and s[1]. The second led, led[1], was turned on by the AND of s[2] and s[3]. Again, I wasn’t able to verify this module with testbenches, but I was able to verify that it functioned as expected by visually confirming correct behavior using hardware.\nFinally, the top level design uses the switch inputs s[3:0] to control logic from the seven-segment and led control modules.\n\n\n\nThe source code for the project can be found in the associated GitHub repository.\n\n\n(Figure 1: Block Diagram of the Verilog Design)\nThe block diagram in Figure 1 demonstrates the overall architecture of the design. The top-level module, top, includes two submodules: the led control module (led_control) and the seven segment display module (seven_seg).\n\n\n\n(Figure 2: Schematic of physical layout)\nFigure 2 shows the physical layout of the design. The seven-segment display was connected using 162 Ω current-limmiting resistors to ensure the output current was about 8 mA. This was calculated using ohms law. The board is being powered with 3.3 V, and the display LEDs (deep red) have a forward voltage of 2 V. Therefore, (3.3 - 2 V) / 162 Ω is ~ 8 mA.\n\n\n\n\nThe design met all intended design objectives. This was verified via visual confirmation of the on-board LEDs and the seven-segment display lighting up as intetned when switches were flipped in different configurations. Given more time, I would have done test bench simulations as this would be a much better tool for verifying that a design works exactly as intended.\n\n\n\nThe design succesfully blinked an on-board LED at 2.4 Hz, toggled on-board LED’s based on XOR and AND gate behavior, and displayed hex digits from 0 to F on a seven-segment display. I spent a total of 15 hours on this lab.\n\n\n\nFor the following AI Prototype, I will be using ChatGPT.\n\n\nWrite SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.\n\n\n\n// Blink an LED at 2 Hz using the internal HFOSC of the UP5K module top ( output logic led // drive LED pin );\n// Internal oscillator (HFOSC) primitive\nlogic clk_hf, clk_en;\n\n// Lattice UP5K HFOSC instantiation\n// CLKHF_DIV: \"0b00\" = 48 MHz, \"0b01\" = 24 MHz, \"0b10\" = 12 MHz\n// Here we choose 12 MHz to make the divider smaller.\nHSOSC #(\n    .CLKHF_DIV(\"0b10\")  // 12 MHz\n) u_hfosc (\n    .CLKHFPU(1'b1),     // power up\n    .CLKHFEN(1'b1),     // enable\n    .CLKHF(clk_hf)      // clock output\n);\n\n// Parameters for blink frequency\nlocalparam int CLK_FREQ_HZ = 12_000_000;   // HFOSC = 12 MHz\nlocalparam int BLINK_HZ    = 2;            // desired blink rate\nlocalparam int HALF_PERIOD = CLK_FREQ_HZ / (2 * BLINK_HZ);\n\n// Counter for frequency division\nlogic [$clog2(HALF_PERIOD)-1:0] counter;\n\n// LED toggle logic\nalways_ff @(posedge clk_hf) begin\n    if (counter == HALF_PERIOD-1) begin\n        counter &lt;= '0;\n        led &lt;= ~led;\n    end else begin\n        counter &lt;= counter + 1;\n    end\nend\nendmodule\n\n\n\nI think the quality of the output is really high because it produced very clean and readable code. I was mostly able to follow the code that was generated, however, it used syntax such as localparam and $clog2 that was new to me. Surprisingly, the LLM-generated code synthesized first round. I think this was largely due to the prompt that it was fed. Thus when using LLMs in my workflow I will make sure to be as descriptive as possible. Next time however, I will make sure to ask about specifc syntax that it’s using that I am not familiar with."
  },
  {
    "objectID": "labs/lab1/lab1.html#lab-1-fpga-and-mcu-setup-and-testing",
    "href": "labs/lab1/lab1.html#lab-1-fpga-and-mcu-setup-and-testing",
    "title": "E155 Portfolio",
    "section": "",
    "text": "In this lab, a design was implemented on the FPGA to demonstrate the functionality of the on-board high-speed oscillator by blinking one of the on-board LEDs. The high speed oscillator was configured at a frequency of 48 MHz and divided down using a counter to achieve a blinking frequency of 2.4 Hz.\nFurthermore, this design used 4 switches as inputs. These switches turned on an on-board LED by acting as a XOR gate and turned on another on-board LED by acting as an AND gate.\nFinally, this design used the same four switches, acting as a four bit binary number, to turn on a seven-segment display to show all hex digits from 0 to F.\n\n\n\nThis design consists of two lower level modules, which control a seven segment display and on-board LEDs. Both of these modules were called within a top level module.\nThe seven-segment module uses a case statemnt to map 4 bit hex digit inputs to its corresponding seven-segment output. As a result, flipping switches s[3:0] would display the correct hex digits ranging from 0 to F. Although, I wasn’t able to verify this module with testbenches, I was able to verify that it functioned as expected by visually confirming correct hex digit representation using hardware.\nThe LED control module was used to blink on-board LEDs. First, the on-board high speed oscillator (HSOSC) was used to generate a 48 MHz signal. Then, a counter set to 20 million was used to divide the clock signal. As a result, led[2] was toggled on and off at a frequency of 2.4 Hz. The other two LEDs were toggled using switches s[3:0]. The first led, led[0], was turned on by the XOR of s[0] and s[1]. The second led, led[1], was turned on by the AND of s[2] and s[3]. Again, I wasn’t able to verify this module with testbenches, but I was able to verify that it functioned as expected by visually confirming correct behavior using hardware.\nFinally, the top level design uses the switch inputs s[3:0] to control logic from the seven-segment and led control modules.\n\n\n\nThe source code for the project can be found in the associated GitHub repository.\n\n\n(Figure 1: Block Diagram of the Verilog Design)\nThe block diagram in Figure 1 demonstrates the overall architecture of the design. The top-level module, top, includes two submodules: the led control module (led_control) and the seven segment display module (seven_seg).\n\n\n\n(Figure 2: Schematic of physical layout)\nFigure 2 shows the physical layout of the design. The seven-segment display was connected using 162 Ω current-limmiting resistors to ensure the output current was about 8 mA. This was calculated using ohms law. The board is being powered with 3.3 V, and the display LEDs (deep red) have a forward voltage of 2 V. Therefore, (3.3 - 2 V) / 162 Ω is ~ 8 mA.\n\n\n\n\nThe design met all intended design objectives. This was verified via visual confirmation of the on-board LEDs and the seven-segment display lighting up as intetned when switches were flipped in different configurations. Given more time, I would have done test bench simulations as this would be a much better tool for verifying that a design works exactly as intended.\n\n\n\nThe design succesfully blinked an on-board LED at 2.4 Hz, toggled on-board LED’s based on XOR and AND gate behavior, and displayed hex digits from 0 to F on a seven-segment display. I spent a total of 15 hours on this lab.\n\n\n\nFor the following AI Prototype, I will be using ChatGPT.\n\n\nWrite SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.\n\n\n\n// Blink an LED at 2 Hz using the internal HFOSC of the UP5K module top ( output logic led // drive LED pin );\n// Internal oscillator (HFOSC) primitive\nlogic clk_hf, clk_en;\n\n// Lattice UP5K HFOSC instantiation\n// CLKHF_DIV: \"0b00\" = 48 MHz, \"0b01\" = 24 MHz, \"0b10\" = 12 MHz\n// Here we choose 12 MHz to make the divider smaller.\nHSOSC #(\n    .CLKHF_DIV(\"0b10\")  // 12 MHz\n) u_hfosc (\n    .CLKHFPU(1'b1),     // power up\n    .CLKHFEN(1'b1),     // enable\n    .CLKHF(clk_hf)      // clock output\n);\n\n// Parameters for blink frequency\nlocalparam int CLK_FREQ_HZ = 12_000_000;   // HFOSC = 12 MHz\nlocalparam int BLINK_HZ    = 2;            // desired blink rate\nlocalparam int HALF_PERIOD = CLK_FREQ_HZ / (2 * BLINK_HZ);\n\n// Counter for frequency division\nlogic [$clog2(HALF_PERIOD)-1:0] counter;\n\n// LED toggle logic\nalways_ff @(posedge clk_hf) begin\n    if (counter == HALF_PERIOD-1) begin\n        counter &lt;= '0;\n        led &lt;= ~led;\n    end else begin\n        counter &lt;= counter + 1;\n    end\nend\nendmodule\n\n\n\nI think the quality of the output is really high because it produced very clean and readable code. I was mostly able to follow the code that was generated, however, it used syntax such as localparam and $clog2 that was new to me. Surprisingly, the LLM-generated code synthesized first round. I think this was largely due to the prompt that it was fed. Thus when using LLMs in my workflow I will make sure to be as descriptive as possible. Next time however, I will make sure to ask about specifc syntax that it’s using that I am not familiar with."
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "Initial Reflections Post",
    "section": "",
    "text": "My main goal for this semester in MicroP’s is to learn new skills that will be useful to me as an electrical engineer. I haven’t had much experience working with embedded systems, so I would love to become more comfortable in this realm. I really enjoy music, so for my final project I think working on something audio related would be really fun."
  },
  {
    "objectID": "labs.html#lab-2-multiplexed-7-segment-display",
    "href": "labs.html#lab-2-multiplexed-7-segment-display",
    "title": "E155 Labs",
    "section": "Lab 2: Multiplexed 7-Segment Display",
    "text": "Lab 2: Multiplexed 7-Segment Display"
  },
  {
    "objectID": "labs.html#lab-3-keypad-scanner",
    "href": "labs.html#lab-3-keypad-scanner",
    "title": "E155 Labs",
    "section": "Lab 3: Keypad Scanner",
    "text": "Lab 3: Keypad Scanner"
  },
  {
    "objectID": "labs.html#lab-4-digital-audio",
    "href": "labs.html#lab-4-digital-audio",
    "title": "E155 Labs",
    "section": "Lab 4: Digital Audio",
    "text": "Lab 4: Digital Audio"
  },
  {
    "objectID": "labs.html#lab-5-interrupts",
    "href": "labs.html#lab-5-interrupts",
    "title": "E155 Labs",
    "section": "Lab 5: Interrupts",
    "text": "Lab 5: Interrupts"
  },
  {
    "objectID": "labs.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "href": "labs.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "title": "E155 Labs",
    "section": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "text": "Lab 6: The Internet of Things and Serial Peripheral Interface"
  },
  {
    "objectID": "labs.html#lab-7-the-advanced-encryption-standard",
    "href": "labs.html#lab-7-the-advanced-encryption-standard",
    "title": "E155 Labs",
    "section": "Lab 7: The Advanced Encryption Standard",
    "text": "Lab 7: The Advanced Encryption Standard"
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "E155 Resources",
    "section": "",
    "text": "E155 Course Website"
  }
]