[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Week 2 of MicroP’s\n\n\nMy thoughts after week 2 of MicroP’s\n\n\n\n\n\nSep 12, 2025\n\n\nMatthew Molinar\n\n\n\n\n\n\n\n\n\n\n\n\nFirst Week of MicroP’s\n\n\nMy thoughts after week 1 of MicroP’s\n\n\n\n\n\nSep 4, 2025\n\n\nMatthew Molinar\n\n\n\n\n\n\n\n\n\n\n\n\nInitial Reflections Post\n\n\nWelcome to my Quarto portfolio\n\n\n\n\n\nAug 27, 2025\n\n\nMatthew Molinar\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Matthew Molinar is an Engineering student at Harvey Mudd College. His interests are in the field of electrical engineering, with a particular focus on RF and digital signal processing."
  },
  {
    "objectID": "posts/second-post.html",
    "href": "posts/second-post.html",
    "title": "First Week of MicroP’s",
    "section": "",
    "text": "I think lab 1 took me a lot longer that I anticipated. Soldering was definitely a time suck and I also hadn’t touched system verilog in so long. That being said, I think the first lab was a good way to revist the system verilog and practice writing a lab report. I’m hoping that lab 2 will be a much smoother sail after having done lab 1. Going into lab 2, I will make sure to start with testbenches before going to hardware. I think this would be a good way to verify that my design works and help save a lot of time debugging."
  },
  {
    "objectID": "posts/third-post.html",
    "href": "posts/third-post.html",
    "title": "Week 2 of MicroP’s",
    "section": "",
    "text": "Lab 2 also took me a good amount of time, but I stuck to my plan of starting with testbenches before trying to build hardware, which saved me a lot of time. I think this strategy saved me a lot of time because when building the circuit I knew for a fact there was a hardware problem, which narrowed down the list of possible bugs. I’m still not the most comfortable with System Verilog, but I definitely feel like I’m sharper especially when compared to my experience in Lab 1. On a different note, I’m really looking forward to working with a MCU in about two week and I think it’ll be fun."
  },
  {
    "objectID": "labs/lab3/lab3.html",
    "href": "labs/lab3/lab3.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "In this lab, I designed a circuit interface using an FPGA to read a 4-by-4 matrix keypad and display the results on a dual seven-segement display. I took into account switch debouncing (a physical phenomenon that mechanical switches are prone to), asynchronous inputs, and implemented a robust digital design to ensure accurate behavior with a variety of user inputs.\n\n\n\n\n\nThis design consists of multiple lower level modules, which use time multiplexing to control two seven-segment displays with 4-by-4 matrix keypad inputs. The most recent key-pad entry appears on the right seven-segment display and the “old” entry appears on the left.\nI first reconfigured my lab 2 modules to take advantage of code I wrote for multiplexing a dual seven-segment display. So, I was able to reuse my lab 2 top module along with the seven_seg module (used to drive a display with a certain hex digit).\nMy keypad_decoder module decodes key press inputs from a 4-by-4 keypad and determines what hex digit was pressed. For example, if the row 0 and column 0 are passed through, then a 1 is pressed.\nNext, the sync module synchronized raw keypad inputs to the FPGA’s clock domain in order to avoid metastabilty caused by asynchronous inputs. This synchronizer was implemented as a chain of two flip flops.\nMy debouncer module was used to counteract switch bounce caused by pressing a mechanical switch. My deboouncer was just a clock divider that waits for a set amount of time before updating the output, ensuring that it’s stable.\nMy keypad_fsm module implements scanning logic to properly drive the seven-segment displays while accomodating different user inputs. My FSM drives all rows as an input and cycles through columns outputting a 1. The row being pressed gets detected allowing for a transition past the IDLE state. Once out of the IDLE state, the columns stop cycling, which keeps the appropriate row and column connected. This will make sure the correct digit corresponding to the users input will be displayed. After passing through all the intermediate states, the FSM stays at the HOLD state, until the user releases the inital key press. Then the cycle can restart allowing for new inputs (see Figure 1).\nFinally, lab3_mm, my top modules, integrated all the lower level modules to display the detected key value on the seven-segment display. Inside this top module, there is a mux that drives the old digit entry to the left display and the newest digit entry to the right display.\n(Figure 1: Keypad FSM State Transition Diagram)\n\n\n\nTesting this design was done via simulation and hardware verification.\nFirst all lower level modules were simulated on their own to make sure they behaved as intended. Then, for simulation of the top module, only a few casses were tested since appropriate behavior was verified in the lower level module testbenches. The top module test bench used the tranif1 primitaive, which is a conditional bidirection switch. Therefore, to model the hardware, I made 16 switches to represent the 4x4 keypad.\n\n\n\n\nThe source code for the project can be found in the associated GitHub repository.\n\n\n(Figure 2.1: lab3_mm Block Diagram of the Verilog Design)\n(Figure 2.2: lab2_mm Block Diagram of the Verilog Design)\n(Figure 2.3: keypad_fsm Block Diagram of the Verilog Design)\nThe block diagram in Figure 2.1 demonstrates the overall architecture of the design. It contains lower level modules sync, lab2_mm (see Figure 2.2), and keypad_fsm (see Figure 2.3).\n\n\n\n(Figure 2: Schematic of physical layout)\nFigure 3 shows the physical layout of the design. The anodes of seven-segment display were connected using 330 Ω current-limmiting resistors and a 2N3906 PNP transitor to ensure the output current was less than 8 mA. The LEDs of the seven-segment display were connected using 1 kΩ resitors, and the 4-by4 matrix keypad’s rows were connected using 10 kΩ pull-down resistors.\n\n\n\nAccording, to the ice40 datasheet, on section 4.17 it says the I/O pins are rated for 8 mA. Thus, I chose 330 Ω resistos for the transistor circuit based on the following calculations:\n\\[\nV = 3.3 - V_f = 3.3 - 0.7 = 2.6 \\, \\text{V}\n\\]\n\\[\nV = IR \\quad \\Rightarrow \\quad R = \\frac{V}{I} = \\frac{2.6}{0.008} = 325 \\, \\Omega\n\\]\nFor the seven-segment display LEDs, I used 1 kΩ resistors based on the following equation:\n\\[\nV = 3.3 - V_f - V{CE(sat)} = 3.3 - 2 - 0.25 = 1.05 \\, \\text{V}\n\\]\n\\[\nV = IR \\quad \\Rightarrow \\quad I = \\frac{V}{R} = \\frac{1.05}{1000} = 1.05 \\, mA\n\\]\nI didn’t want the LEDs on the display to run too hot or be too bright, so I just used 1 kΩ resistors resulting in a current of 1.3 mA.\n\n\n\n\n\n\n(Figure 4: A screenshot of a QuestaSim simulation demonstrating that the debouncer functions as expected.)\n(Figure 5: A screenshot of a QuestaSim simulation demonstrating that the keypad decoder decodes key switch inputs as expected.)\n(Figure 6: A screenshot of a QuestaSim simulation demonstrating the FSM works correctly and that state transitions happen go to the correct states after certain stimuli.)\n(Figure 7: A screenshot of a QuestaSim simulation demonstrating that the synchronizer has its intended behavior.)\n(Figure 8: A screenshot of a QuestaSim simulation demonstrating that all sub-modules work together accurately to scan and read user inputs on a 4-by-4 matrix keypad.)\n(Figure 9: A screenshot of a QuestaSim simulation message demonstrating that all tests in the above simulation passed.)\nThe design met most intended design objectives. Figure 4 shows that the debouncer module works as a counter to avoid one key press being registered as multiple inputs. Figure 5 shows that the keypad decoder accurately decodes user inputs on a 4-by-4 keypad. Figure 6 shows that the FSM works in that it under goes the correct transitions at the right times. Figure 7 shows that the synchonizer uses a chain of two flip-flops to synchronize asynchronous inputs. Finally, Figures 8 and 9 show that the top module works as intended and that it accurately merges all sub-modules.\n\n\n\nAfter simulation was done, a 4-by-4 keypad was connected and the keypresses were tested. The correct hex digits were displayed on the appropriate seven-segment displays, the design doesn’t lock up when multiple buttons are pressed at once, and each number is only registered once (no switch bouncing).\n\n\n\n\nThe design succesfully detected and displayed keypad inputs on the dual seven-segment display without locking up and without registering a number more than once. However, I wasn’t able to cover the case where I would hold one key, press another, then release the first key. In this case, the first key should go to the left display after relaesed, and the second key that is still being held should appear on the right. This was only an issue when pressing keys in the same column, and I think this is the case because pressing keys on the same column would cause a short keeping the FSM in the HOLD state. I spent a total of 25 hours on this lab.\n\n\n\nFor the following AI Prototype, I will be using ChatGPT.\n\n\nTarget device: Lattice iCE40 UP5K FPGA with internal high-speed oscillator (~20 MHz).\nWrite synthesizable SystemVerilog to scan a 4x4 matrix keypad and display the last two hex keys pressed on a dual 7‑segment display. Implement:\nA clock divider that derives a scan clock on the order of 100–200 Hz from the internal oscillator. A keypad scanning controller that iterates one active‑low column at a time and samples active‑low rows, registering at most one key per press (debounce‑by‑design), ignoring additional presses while any key is held, and allowing a new registration only after release. A top level that updates two hex digits (older and most recent) when a new key is registered and drives a time‑multiplexed two‑digit 7‑segment display without visible flicker and with balanced brightness. Use idiomatic SystemVerilog (e.g., logic, always_ff, enumerated states for FSMs). Provide clean module boundaries and keep all state synchronous. Include brief comments explaining the design choices.\n\n\n\n\n\nTarget device: Lattice iCE40 UP5K FPGA.\nOverall Goal: Write SystemVerilog to scan a 4x4 matrix keypad and display the last two hex keys pressed on a dual 7 segment display.\nCurrent Goal: Write a synthesizable SystemVerilog module that produces a one‑shot registration signal for the keypad system. Behavior:\nWhen a key press is first detected, capture the current key code and assert a single‑cycle “new key” pulse. While any key remains pressed, do not accept additional keys. Only after keys are released should a subsequent press be recognized. This should handle debouncing of the keys. Implement as a small synchronous FSM with enumerated states and glitch‑free outputs. Keep names and interfaces reasonable; do not assume any hidden modules beyond what you define here.\n\n\n\nTarget device: Lattice iCE40 UP5K FPGA.\nWrite a synthesizable SystemVerilog module that cycles through keypad columns (active‑low, one at a time) and samples rows (active‑low) to detect a single key at a time. Behavior:\nIterate columns at a suitable scan rate derived from the divided clock and sample rows. When a key is detected, report a stable key code consistent with a standard 4x4 keypad layout and maintain it while the key remains pressed. Provide a boolean signal indicating whether any key is currently pressed. Use clean state encoding and synchronous logic; avoid combinational feedback and latches.\n\n\n\nTarget device: Lattice iCE40 UP5K FPGA with internal oscillator as the root clock source.\nWrite a top‑level SystemVerilog module that instantiates the scanner and one‑shot modules, shifts the last two keys (older ← most recent; most recent ← new), and drives a multiplexed two‑digit seven‑segment display. Requirements:\nUpdate the displayed digits only when a new key is registered. Ensure equal apparent brightness and no visible flicker. Keep all logic synthesizable and synchronous; use idiomatic SystemVerilog constructs. Provide any small clock‑enable or divider logic you need. You can also assume that a sevenSegment module exists that takes a 4 bit input and outputs the 7 segments.\n\n\n\nThe code generated for these prompts can be found here.\n\n\n\n\nThe monoloithic prompt synthesized first try while the modular prompt did not. I find this to be very surprising because I thought that if your peompt was too large, then LLMs wouldn’t be able to produce accurate results since there is too much context. I feel like modularizing prompts improved readability because it split the lab into multiple files, but then I had asked it to combine everything into one file, which is probably where it went wrong. The modular did modularize the design in a similar way in which the prompts were split up, which is to be expected because it was prompted in that way to do so. One interesting SystemVerilog idiom that the LLM used was “function automatic logic”. I thought this was weird/surprising because I don’t really understand the point in this. When trying to synthesize the modular prompts, it kept running into the following error, even after being fed the message: an enum variable may only be assigned to same enum typed variable or one of its values. As a result of these tests, the next time I use AI I think it’s probably best to give AI as much context as possible so that its output covers all behavior you intend for."
  },
  {
    "objectID": "labs/lab3/lab3.html#lab-3-keypad-scanner",
    "href": "labs/lab3/lab3.html#lab-3-keypad-scanner",
    "title": "E155 Portfolio",
    "section": "",
    "text": "In this lab, I designed a circuit interface using an FPGA to read a 4-by-4 matrix keypad and display the results on a dual seven-segement display. I took into account switch debouncing (a physical phenomenon that mechanical switches are prone to), asynchronous inputs, and implemented a robust digital design to ensure accurate behavior with a variety of user inputs.\n\n\n\n\n\nThis design consists of multiple lower level modules, which use time multiplexing to control two seven-segment displays with 4-by-4 matrix keypad inputs. The most recent key-pad entry appears on the right seven-segment display and the “old” entry appears on the left.\nI first reconfigured my lab 2 modules to take advantage of code I wrote for multiplexing a dual seven-segment display. So, I was able to reuse my lab 2 top module along with the seven_seg module (used to drive a display with a certain hex digit).\nMy keypad_decoder module decodes key press inputs from a 4-by-4 keypad and determines what hex digit was pressed. For example, if the row 0 and column 0 are passed through, then a 1 is pressed.\nNext, the sync module synchronized raw keypad inputs to the FPGA’s clock domain in order to avoid metastabilty caused by asynchronous inputs. This synchronizer was implemented as a chain of two flip flops.\nMy debouncer module was used to counteract switch bounce caused by pressing a mechanical switch. My deboouncer was just a clock divider that waits for a set amount of time before updating the output, ensuring that it’s stable.\nMy keypad_fsm module implements scanning logic to properly drive the seven-segment displays while accomodating different user inputs. My FSM drives all rows as an input and cycles through columns outputting a 1. The row being pressed gets detected allowing for a transition past the IDLE state. Once out of the IDLE state, the columns stop cycling, which keeps the appropriate row and column connected. This will make sure the correct digit corresponding to the users input will be displayed. After passing through all the intermediate states, the FSM stays at the HOLD state, until the user releases the inital key press. Then the cycle can restart allowing for new inputs (see Figure 1).\nFinally, lab3_mm, my top modules, integrated all the lower level modules to display the detected key value on the seven-segment display. Inside this top module, there is a mux that drives the old digit entry to the left display and the newest digit entry to the right display.\n(Figure 1: Keypad FSM State Transition Diagram)\n\n\n\nTesting this design was done via simulation and hardware verification.\nFirst all lower level modules were simulated on their own to make sure they behaved as intended. Then, for simulation of the top module, only a few casses were tested since appropriate behavior was verified in the lower level module testbenches. The top module test bench used the tranif1 primitaive, which is a conditional bidirection switch. Therefore, to model the hardware, I made 16 switches to represent the 4x4 keypad.\n\n\n\n\nThe source code for the project can be found in the associated GitHub repository.\n\n\n(Figure 2.1: lab3_mm Block Diagram of the Verilog Design)\n(Figure 2.2: lab2_mm Block Diagram of the Verilog Design)\n(Figure 2.3: keypad_fsm Block Diagram of the Verilog Design)\nThe block diagram in Figure 2.1 demonstrates the overall architecture of the design. It contains lower level modules sync, lab2_mm (see Figure 2.2), and keypad_fsm (see Figure 2.3).\n\n\n\n(Figure 2: Schematic of physical layout)\nFigure 3 shows the physical layout of the design. The anodes of seven-segment display were connected using 330 Ω current-limmiting resistors and a 2N3906 PNP transitor to ensure the output current was less than 8 mA. The LEDs of the seven-segment display were connected using 1 kΩ resitors, and the 4-by4 matrix keypad’s rows were connected using 10 kΩ pull-down resistors.\n\n\n\nAccording, to the ice40 datasheet, on section 4.17 it says the I/O pins are rated for 8 mA. Thus, I chose 330 Ω resistos for the transistor circuit based on the following calculations:\n\\[\nV = 3.3 - V_f = 3.3 - 0.7 = 2.6 \\, \\text{V}\n\\]\n\\[\nV = IR \\quad \\Rightarrow \\quad R = \\frac{V}{I} = \\frac{2.6}{0.008} = 325 \\, \\Omega\n\\]\nFor the seven-segment display LEDs, I used 1 kΩ resistors based on the following equation:\n\\[\nV = 3.3 - V_f - V{CE(sat)} = 3.3 - 2 - 0.25 = 1.05 \\, \\text{V}\n\\]\n\\[\nV = IR \\quad \\Rightarrow \\quad I = \\frac{V}{R} = \\frac{1.05}{1000} = 1.05 \\, mA\n\\]\nI didn’t want the LEDs on the display to run too hot or be too bright, so I just used 1 kΩ resistors resulting in a current of 1.3 mA.\n\n\n\n\n\n\n(Figure 4: A screenshot of a QuestaSim simulation demonstrating that the debouncer functions as expected.)\n(Figure 5: A screenshot of a QuestaSim simulation demonstrating that the keypad decoder decodes key switch inputs as expected.)\n(Figure 6: A screenshot of a QuestaSim simulation demonstrating the FSM works correctly and that state transitions happen go to the correct states after certain stimuli.)\n(Figure 7: A screenshot of a QuestaSim simulation demonstrating that the synchronizer has its intended behavior.)\n(Figure 8: A screenshot of a QuestaSim simulation demonstrating that all sub-modules work together accurately to scan and read user inputs on a 4-by-4 matrix keypad.)\n(Figure 9: A screenshot of a QuestaSim simulation message demonstrating that all tests in the above simulation passed.)\nThe design met most intended design objectives. Figure 4 shows that the debouncer module works as a counter to avoid one key press being registered as multiple inputs. Figure 5 shows that the keypad decoder accurately decodes user inputs on a 4-by-4 keypad. Figure 6 shows that the FSM works in that it under goes the correct transitions at the right times. Figure 7 shows that the synchonizer uses a chain of two flip-flops to synchronize asynchronous inputs. Finally, Figures 8 and 9 show that the top module works as intended and that it accurately merges all sub-modules.\n\n\n\nAfter simulation was done, a 4-by-4 keypad was connected and the keypresses were tested. The correct hex digits were displayed on the appropriate seven-segment displays, the design doesn’t lock up when multiple buttons are pressed at once, and each number is only registered once (no switch bouncing).\n\n\n\n\nThe design succesfully detected and displayed keypad inputs on the dual seven-segment display without locking up and without registering a number more than once. However, I wasn’t able to cover the case where I would hold one key, press another, then release the first key. In this case, the first key should go to the left display after relaesed, and the second key that is still being held should appear on the right. This was only an issue when pressing keys in the same column, and I think this is the case because pressing keys on the same column would cause a short keeping the FSM in the HOLD state. I spent a total of 25 hours on this lab.\n\n\n\nFor the following AI Prototype, I will be using ChatGPT.\n\n\nTarget device: Lattice iCE40 UP5K FPGA with internal high-speed oscillator (~20 MHz).\nWrite synthesizable SystemVerilog to scan a 4x4 matrix keypad and display the last two hex keys pressed on a dual 7‑segment display. Implement:\nA clock divider that derives a scan clock on the order of 100–200 Hz from the internal oscillator. A keypad scanning controller that iterates one active‑low column at a time and samples active‑low rows, registering at most one key per press (debounce‑by‑design), ignoring additional presses while any key is held, and allowing a new registration only after release. A top level that updates two hex digits (older and most recent) when a new key is registered and drives a time‑multiplexed two‑digit 7‑segment display without visible flicker and with balanced brightness. Use idiomatic SystemVerilog (e.g., logic, always_ff, enumerated states for FSMs). Provide clean module boundaries and keep all state synchronous. Include brief comments explaining the design choices.\n\n\n\n\n\nTarget device: Lattice iCE40 UP5K FPGA.\nOverall Goal: Write SystemVerilog to scan a 4x4 matrix keypad and display the last two hex keys pressed on a dual 7 segment display.\nCurrent Goal: Write a synthesizable SystemVerilog module that produces a one‑shot registration signal for the keypad system. Behavior:\nWhen a key press is first detected, capture the current key code and assert a single‑cycle “new key” pulse. While any key remains pressed, do not accept additional keys. Only after keys are released should a subsequent press be recognized. This should handle debouncing of the keys. Implement as a small synchronous FSM with enumerated states and glitch‑free outputs. Keep names and interfaces reasonable; do not assume any hidden modules beyond what you define here.\n\n\n\nTarget device: Lattice iCE40 UP5K FPGA.\nWrite a synthesizable SystemVerilog module that cycles through keypad columns (active‑low, one at a time) and samples rows (active‑low) to detect a single key at a time. Behavior:\nIterate columns at a suitable scan rate derived from the divided clock and sample rows. When a key is detected, report a stable key code consistent with a standard 4x4 keypad layout and maintain it while the key remains pressed. Provide a boolean signal indicating whether any key is currently pressed. Use clean state encoding and synchronous logic; avoid combinational feedback and latches.\n\n\n\nTarget device: Lattice iCE40 UP5K FPGA with internal oscillator as the root clock source.\nWrite a top‑level SystemVerilog module that instantiates the scanner and one‑shot modules, shifts the last two keys (older ← most recent; most recent ← new), and drives a multiplexed two‑digit seven‑segment display. Requirements:\nUpdate the displayed digits only when a new key is registered. Ensure equal apparent brightness and no visible flicker. Keep all logic synthesizable and synchronous; use idiomatic SystemVerilog constructs. Provide any small clock‑enable or divider logic you need. You can also assume that a sevenSegment module exists that takes a 4 bit input and outputs the 7 segments.\n\n\n\nThe code generated for these prompts can be found here.\n\n\n\n\nThe monoloithic prompt synthesized first try while the modular prompt did not. I find this to be very surprising because I thought that if your peompt was too large, then LLMs wouldn’t be able to produce accurate results since there is too much context. I feel like modularizing prompts improved readability because it split the lab into multiple files, but then I had asked it to combine everything into one file, which is probably where it went wrong. The modular did modularize the design in a similar way in which the prompts were split up, which is to be expected because it was prompted in that way to do so. One interesting SystemVerilog idiom that the LLM used was “function automatic logic”. I thought this was weird/surprising because I don’t really understand the point in this. When trying to synthesize the modular prompts, it kept running into the following error, even after being fed the message: an enum variable may only be assigned to same enum typed variable or one of its values. As a result of these tests, the next time I use AI I think it’s probably best to give AI as much context as possible so that its output covers all behavior you intend for."
  },
  {
    "objectID": "labs/lab5/lab5.html",
    "href": "labs/lab5/lab5.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "In this lab, I used an MCU to determine the speed of a motor by reading from a quadrature encoder using interrupts.\n\n\n\n\n\nThis design interrupts to detect pulses from the encoder and calculate the veolcity and direction the motor is spinning in. For both interrupts, rising and falling edge triggers are enabled to achieve the highest resolution measuremnt. Finally, the speed and direction is displayed using fprintf() in units of rev/s at a rate of 2 Hz.\nAs far as hardware goes, the design uses a 25GA-370 DC Motor and a power supply to adjust the speed.\n\n\n\nTesting this design was done via hardware verification. The motor was connected to the MCU, and I ensured an accurate velocity measurement was being displayed on the debugging window.\n\n\n\n\nThe source code for the project can be found in the associated GitHub repository.\n\n\n(Figure 1: Schematic of physical layout)\nFigure 1 shows the physical layout of the design. The MCU was connected to a 25GA-370 DC Motor, which was also powered with an external power supply.\n\n\n\n(Figure 2: Interrupt Flowchart)\nFigure 2 shows each interrupt and the main loop that is executed.\n\n\n\nFirst, I counted the number of pulses and used the following equation to find speed in terms of revolutions per second. Here, count refers to the pulse count and time referes to the time in ms. I was using a display rate of 2 Hz, so time was 500 ms.\n\\[\nrps = \\frac{\\text{count} \\times \\left(\\frac{1000}{\\text{time}}\\right)}{4 \\times 408}\n\\]\nTo find the true motor speed, I plugged one of the GPIO pins to an oscilloscope and measured the period of a pulse. Then I used the following eqaution to calculate speed in terms of revolutions per second. \\[\nrps = \\frac{1}{period \\times 408}\n\\]\n(Figure 3: Oscilloscope trace of a GPIO pin)\nFigure 3 shows each interrupt and the main loop that is executed. Here the period is 1.040 ms, so plugging into the equation above, I get a true motor speed of 2.36 rps at 10 V. This is similar to my measured speed which is around 2.4 rps at 10 V.\n\n\n\n\n\n\nAccurate speeds were being measured from the motor and displayed in debugging mode at a rate of 2 Hz.\n\n\n\n(Figure 3: Interrupt Oscilloscope Trace)\n(Figure 4: Polling Oscilloscope Trace)\nFigures 3 and 4 compare interrupt based code vs. polling at high speeds. In both traces, the blue signal is an input signal from the motor, and the yellow signal is an output signal from a GPIO pin, which just flips at each edge. In both cases I put a 100 ms delay in the main loop. Figure 3 shows that the interrupts can register inputs and then output something with minimal delay. However, Figure 4 shows the polling method where the output trace (in yellow is heavily aliased). This is because the polling method requires waiting the full 100 ms everytime which is much slower than the input frequency. On the other hand, the interrupt bypasses this. This supports the fact that if the polling period is T, then the average interface latency would be T/2, or at worst T Chapter 12: Interrupts. On the other hand, interrupts have much smaller latency.\n\n\n\n\nThis design sucessfully used two interrupts to read from a quadrature encoder and measure and record the speed and direction in which a motor is spinning. I spent a total of 10 hours on this lab.\n\n\n\nFor the following AI Prototype, I will be using ChatGPT.\n\n\nWrite me interrupt handlers to interface with a quadrature encoder. I’m using the STM32L432KC, what pins should I connect the encoder to in order to allow it to easily trigger the interrupts?\n\n\n\nAccording to ChatGPT, I should use pins STM32 HAL is easier. In this method, each edge (rising or falling) is triggered, the ISR reads A and B to determine direction, and encoder updates its count accordingly.\n\n\n\nThe code generated for these prompts can be found here.\n\n\n\nI think the quality of the output was not great. I think at a high-level, the LLM understood what to do, but from what I could tell, the implementation was not quite there. First, it used the hardware abstraction layer STM32 HAL, which is reasonable, but I didn’t understand what it was untill I asked. The LLM generated code that was different than mine. It used STM32 HAL, different pins, and included all code in one file. For some reason, the LLM suggested a polling type method using timers, but I think this is just a hallucination because using polling will cause some latency. Overall, I think the LLM does work better as a sounding board as opposed to just generating code, because it often has bugs in the code it generates."
  },
  {
    "objectID": "labs/lab5/lab5.html#lab-5-interrupts",
    "href": "labs/lab5/lab5.html#lab-5-interrupts",
    "title": "E155 Portfolio",
    "section": "",
    "text": "In this lab, I used an MCU to determine the speed of a motor by reading from a quadrature encoder using interrupts.\n\n\n\n\n\nThis design interrupts to detect pulses from the encoder and calculate the veolcity and direction the motor is spinning in. For both interrupts, rising and falling edge triggers are enabled to achieve the highest resolution measuremnt. Finally, the speed and direction is displayed using fprintf() in units of rev/s at a rate of 2 Hz.\nAs far as hardware goes, the design uses a 25GA-370 DC Motor and a power supply to adjust the speed.\n\n\n\nTesting this design was done via hardware verification. The motor was connected to the MCU, and I ensured an accurate velocity measurement was being displayed on the debugging window.\n\n\n\n\nThe source code for the project can be found in the associated GitHub repository.\n\n\n(Figure 1: Schematic of physical layout)\nFigure 1 shows the physical layout of the design. The MCU was connected to a 25GA-370 DC Motor, which was also powered with an external power supply.\n\n\n\n(Figure 2: Interrupt Flowchart)\nFigure 2 shows each interrupt and the main loop that is executed.\n\n\n\nFirst, I counted the number of pulses and used the following equation to find speed in terms of revolutions per second. Here, count refers to the pulse count and time referes to the time in ms. I was using a display rate of 2 Hz, so time was 500 ms.\n\\[\nrps = \\frac{\\text{count} \\times \\left(\\frac{1000}{\\text{time}}\\right)}{4 \\times 408}\n\\]\nTo find the true motor speed, I plugged one of the GPIO pins to an oscilloscope and measured the period of a pulse. Then I used the following eqaution to calculate speed in terms of revolutions per second. \\[\nrps = \\frac{1}{period \\times 408}\n\\]\n(Figure 3: Oscilloscope trace of a GPIO pin)\nFigure 3 shows each interrupt and the main loop that is executed. Here the period is 1.040 ms, so plugging into the equation above, I get a true motor speed of 2.36 rps at 10 V. This is similar to my measured speed which is around 2.4 rps at 10 V.\n\n\n\n\n\n\nAccurate speeds were being measured from the motor and displayed in debugging mode at a rate of 2 Hz.\n\n\n\n(Figure 3: Interrupt Oscilloscope Trace)\n(Figure 4: Polling Oscilloscope Trace)\nFigures 3 and 4 compare interrupt based code vs. polling at high speeds. In both traces, the blue signal is an input signal from the motor, and the yellow signal is an output signal from a GPIO pin, which just flips at each edge. In both cases I put a 100 ms delay in the main loop. Figure 3 shows that the interrupts can register inputs and then output something with minimal delay. However, Figure 4 shows the polling method where the output trace (in yellow is heavily aliased). This is because the polling method requires waiting the full 100 ms everytime which is much slower than the input frequency. On the other hand, the interrupt bypasses this. This supports the fact that if the polling period is T, then the average interface latency would be T/2, or at worst T Chapter 12: Interrupts. On the other hand, interrupts have much smaller latency.\n\n\n\n\nThis design sucessfully used two interrupts to read from a quadrature encoder and measure and record the speed and direction in which a motor is spinning. I spent a total of 10 hours on this lab.\n\n\n\nFor the following AI Prototype, I will be using ChatGPT.\n\n\nWrite me interrupt handlers to interface with a quadrature encoder. I’m using the STM32L432KC, what pins should I connect the encoder to in order to allow it to easily trigger the interrupts?\n\n\n\nAccording to ChatGPT, I should use pins STM32 HAL is easier. In this method, each edge (rising or falling) is triggered, the ISR reads A and B to determine direction, and encoder updates its count accordingly.\n\n\n\nThe code generated for these prompts can be found here.\n\n\n\nI think the quality of the output was not great. I think at a high-level, the LLM understood what to do, but from what I could tell, the implementation was not quite there. First, it used the hardware abstraction layer STM32 HAL, which is reasonable, but I didn’t understand what it was untill I asked. The LLM generated code that was different than mine. It used STM32 HAL, different pins, and included all code in one file. For some reason, the LLM suggested a polling type method using timers, but I think this is just a hallucination because using polling will cause some latency. Overall, I think the LLM does work better as a sounding board as opposed to just generating code, because it often has bugs in the code it generates."
  },
  {
    "objectID": "labs/lab6/lab6.html",
    "href": "labs/lab6/lab6.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "In this lab, I desined and built a simple IoT device. I interfaced with a temperature senesor module over an SPI link and interfaced the MCU with an ESP8266 module over a UART link. Ultimately, there was an HTML page that could control an LED and display the temperature read from the temperature sensor according to the bit resolution set by the user.\n\n\n\n\n\nThis design interfaced with a temperature sensor module over an SPI link. The SPI functionality of the MCU was implemented in C using CMSIS device templates.\nAdditionally, the MCU interfaced with an ESP8266 module via a UART link in order to host a webpage. On this webpage, the user can toggle an LED on and off. The user can also select the bit resolution (8-12 bits) at which the temperature is being read/displayed on the webpage.\n\n\n\nTesting this design was done via hardware verification. First, I made a simple script that transmitted a very simple message via SPI. Then, I connected the MCU with a logic analyzer in order to verify that SPI was functioning (the decoded message displayed properly). Then, I tested the LED toggling and temperature reading by exhausting all the inputs on the webpage.\n(Figure 1: Example SPI Transaction)\nFigure 1 shows an example SPI transaction from the temperature sensor.\n\n\n\n\nThe source code for the project can be found in the associated GitHub repository.\n\n\n(Figure 2: Schematic of physical layout)\nFigure 2 shows the physical layout of the design. The MCU was connected to a DS1722 digital temperature sensor and was connected via a SPI link. The MCU was also connected to an ESP8266 via a UART link, which hosted a webpage displayed on the monitor of the computer it was connected to.\n\n\n\n\n\n\nThe LED was able to be toggled based on user inputs on the webpage. The webpage also displayed accurate temperature readings with different resolutions based on user inputs. Below is a screenshot of the working webpage.\n(Figure 3: Screenshot of Working Webpage)\n\n\n\n\nThis design sucessfully used SPI to interface with a digital temperature sensor. It also used UART to interface with an ESP8266 which hosted a webpage that allowed a user to toggle an LED and read temperatures at different resolutions. I spent a total of 17 hours on this lab. Unfortunately, I think a lot of time was spent fideling around with the logic analyzer in order to capture a SPI transaction of the temperature sensor.\n\n\n\nFor the following AI Prototype, I will be using ChatGPT.\n\n\nI’m making a web portal to interface with a temperature sensor. Create a HTML page that looks good and is intuitive to show the temperature, control an LED, and change the precision of the readout.\n\n\n(Figure 4: Webpage created by ChatGPT)\n\n\n\n\nWrite me a C function to carry out a SPI transaction to retrieve a temperature reading from a DS1722 sensor. Make use of CMSIS libraries for the STM32L432KC.\n\n\n\nThe code generated for these prompts can be found here.\n\n\n\nChatGPT ended up preforming decently. The webpage that it created using the first prompt (see Figure 3) looked pretty nice, although it did not interface cleanly with the project. One major issue with the webpage is that the bit resolution was configurable starting at 1 bit. This didn’t make sense because the DS1722 has an adjustable bit resolution from 8-12 bits.\nUltimately though, I think this result was more accurate than the second prompt. I think the main issue that ChatGPT’s code failed was because SPI_CE was set to its alternate function of SPI_NSS instead of just a regular GPIO output. This would cause the DS1722 to never be selected."
  },
  {
    "objectID": "labs/lab6/lab6.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "href": "labs/lab6/lab6.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "title": "E155 Portfolio",
    "section": "",
    "text": "In this lab, I desined and built a simple IoT device. I interfaced with a temperature senesor module over an SPI link and interfaced the MCU with an ESP8266 module over a UART link. Ultimately, there was an HTML page that could control an LED and display the temperature read from the temperature sensor according to the bit resolution set by the user.\n\n\n\n\n\nThis design interfaced with a temperature sensor module over an SPI link. The SPI functionality of the MCU was implemented in C using CMSIS device templates.\nAdditionally, the MCU interfaced with an ESP8266 module via a UART link in order to host a webpage. On this webpage, the user can toggle an LED on and off. The user can also select the bit resolution (8-12 bits) at which the temperature is being read/displayed on the webpage.\n\n\n\nTesting this design was done via hardware verification. First, I made a simple script that transmitted a very simple message via SPI. Then, I connected the MCU with a logic analyzer in order to verify that SPI was functioning (the decoded message displayed properly). Then, I tested the LED toggling and temperature reading by exhausting all the inputs on the webpage.\n(Figure 1: Example SPI Transaction)\nFigure 1 shows an example SPI transaction from the temperature sensor.\n\n\n\n\nThe source code for the project can be found in the associated GitHub repository.\n\n\n(Figure 2: Schematic of physical layout)\nFigure 2 shows the physical layout of the design. The MCU was connected to a DS1722 digital temperature sensor and was connected via a SPI link. The MCU was also connected to an ESP8266 via a UART link, which hosted a webpage displayed on the monitor of the computer it was connected to.\n\n\n\n\n\n\nThe LED was able to be toggled based on user inputs on the webpage. The webpage also displayed accurate temperature readings with different resolutions based on user inputs. Below is a screenshot of the working webpage.\n(Figure 3: Screenshot of Working Webpage)\n\n\n\n\nThis design sucessfully used SPI to interface with a digital temperature sensor. It also used UART to interface with an ESP8266 which hosted a webpage that allowed a user to toggle an LED and read temperatures at different resolutions. I spent a total of 17 hours on this lab. Unfortunately, I think a lot of time was spent fideling around with the logic analyzer in order to capture a SPI transaction of the temperature sensor.\n\n\n\nFor the following AI Prototype, I will be using ChatGPT.\n\n\nI’m making a web portal to interface with a temperature sensor. Create a HTML page that looks good and is intuitive to show the temperature, control an LED, and change the precision of the readout.\n\n\n(Figure 4: Webpage created by ChatGPT)\n\n\n\n\nWrite me a C function to carry out a SPI transaction to retrieve a temperature reading from a DS1722 sensor. Make use of CMSIS libraries for the STM32L432KC.\n\n\n\nThe code generated for these prompts can be found here.\n\n\n\nChatGPT ended up preforming decently. The webpage that it created using the first prompt (see Figure 3) looked pretty nice, although it did not interface cleanly with the project. One major issue with the webpage is that the bit resolution was configurable starting at 1 bit. This didn’t make sense because the DS1722 has an adjustable bit resolution from 8-12 bits.\nUltimately though, I think this result was more accurate than the second prompt. I think the main issue that ChatGPT’s code failed was because SPI_CE was set to its alternate function of SPI_NSS instead of just a regular GPIO output. This would cause the DS1722 to never be selected."
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "In this lab, a design was implemented on the FPGA to demonstrate the functionality of the on-board high-speed oscillator by blinking one of the on-board LEDs. The high speed oscillator was configured at a frequency of 48 MHz and divided down using a counter to achieve a blinking frequency of 2.4 Hz.\nFurthermore, this design used 4 switches as inputs. These switches turned on an on-board LED by acting as a XOR gate and turned on another on-board LED by acting as an AND gate.\nFinally, this design used the same four switches, acting as a four bit binary number, to turn on a seven-segment display to show all hex digits from 0 to F.\n\n\n\n\n\nThis design consists of two lower level modules, which control a seven segment display and on-board LEDs. Both of these modules were called within a top level module.\nThe seven-segment module uses a case statemnt to map 4 bit hex digit inputs to its corresponding seven-segment output. As a result, flipping switches s[3:0] would display the correct hex digits ranging from 0 to F.\nThe LED control module was used to blink on-board LEDs. First, the on-board high speed oscillator (HSOSC) was used to generate a 48 MHz signal. Then, a counter set to 20 million was used to divide the clock signal. As a result, led[2] was toggled on and off at a frequency of 2.4 Hz. The other two LEDs were toggled using switches s[3:0]. The first led, led[0], was turned on by the XOR of s[0] and s[1]. The second led, led[1], was turned on by the AND of s[2] and s[3].\nFinally, the top level design uses the switch inputs s[3:0] to control logic from the seven-segment and led control modules.\n\n\n\nTesting this design was done via simulation and hardware verification.\nFirst, all lower level modules were tested on their own to make sure all possible inputs work. Then, for simulation of the top module I made sure to test all posible inputs for lower level modules to make sure they interacted properly.\nFor hardware verification, I was able to verify that it functioned as expected by visually confirming correct hex digit representation using hardware. I was also able to verify that the LEDs lit up properly with visual confirmation.\n\n\n\n\nThe source code for the project can be found in the associated GitHub repository.\n\n\n(Figure 1: Block Diagram of the Verilog Design)\nThe block diagram in Figure 1 demonstrates the overall architecture of the design. The top-level module, top, includes two submodules: the led control module (led_control) and the seven segment display module (seven_seg).\n\n\n\n(Figure 2: Schematic of physical layout)\nFigure 2 shows the physical layout of the design. The seven-segment display was connected using 162 Ω current-limmiting resistors to ensure the output current was about 8 mA. This was calculated using ohms law. The board is being powered with 3.3 V, and the display LEDs (deep red) have a forward voltage of 2 V. Therefore, (3.3 - 2 V) / 162 Ω is ~ 8 mA.\n\n\n\n\n\n\n(Figure 3: A screenshot of a QuestaSim simulation demonstrating accurate control and behavior of the LEDs.)\n(Figure 4: A screenshot of a QuestaSim simulation demonstrating proper driving of the seven-segment display.)\n(Figure 5: A screenshot of a QuestaSim simulation demonstrating that all sub-modules works together accurately within the top module.)\nThe design met all intended design objectives. Figure 3 shows that the led_control module works as intended. Any red signals are just don’t cares (x’s) for one of the LEDs. Figure 4 shows that the seven_seg module works as intdended and that I’m able to drive a seven-segment display as intended. Finally, Figure 5 shows that the top module works as intended and that it accurately merges all sub-modules. Again, any red signals are just don’t cares (x’s) from one of the LEDs.\n\n\n\nHardware was also tested via visual confirmation of the on-board LEDs and the seven-segment display lighting up as intetned when switches were flipped in different configurations.\n\n\n\n\nThe design succesfully blinked an on-board LED at 2.4 Hz, toggled on-board LED’s based on XOR and AND gate behavior, and displayed hex digits from 0 to F on a seven-segment display. I spent a total of 15 hours on this lab.\n\n\n\nFor the following AI Prototype, I will be using ChatGPT.\n\n\nWrite SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.\n\n\n\n// Blink an LED at 2 Hz using the internal HFOSC of the UP5K\nmodule top (\n    output logic led   // drive LED pin\n);\n\n    // Internal oscillator (HFOSC) primitive\n    logic clk_hf, clk_en;\n\n    // Lattice UP5K HFOSC instantiation\n    // CLKHF_DIV: \"0b00\" = 48 MHz, \"0b01\" = 24 MHz, \"0b10\" = 12 MHz\n    // Here we choose 12 MHz to make the divider smaller.\n    HSOSC #(\n        .CLKHF_DIV(\"0b10\")  // 12 MHz\n    ) u_hfosc (\n        .CLKHFPU(1'b1),     // power up\n        .CLKHFEN(1'b1),     // enable\n        .CLKHF(clk_hf)      // clock output\n    );\n\n    // Parameters for blink frequency\n    localparam int CLK_FREQ_HZ = 12_000_000;   // HFOSC = 12 MHz\n    localparam int BLINK_HZ    = 2;            // desired blink rate\n    localparam int HALF_PERIOD = CLK_FREQ_HZ / (2 * BLINK_HZ);\n\n    // Counter for frequency division\n    logic [$clog2(HALF_PERIOD)-1:0] counter;\n\n    // LED toggle logic\n    always_ff @(posedge clk_hf) begin\n        if (counter == HALF_PERIOD-1) begin\n            counter &lt;= '0;\n            led &lt;= ~led;\n        end else begin\n            counter &lt;= counter + 1;\n        end\n    end\n\nendmodule\n\n\n\nI think the quality of the output is really high because it produced very clean and readable code. I was mostly able to follow the code that was generated, however, it used syntax such as localparam and $clog2 that was new to me. Surprisingly, the LLM-generated code synthesized first round. I think this was largely due to the prompt that it was fed. Thus when using LLMs in my workflow I will make sure to be as descriptive as possible. Next time however, I will make sure to ask about specifc syntax that it’s using that I am not familiar with."
  },
  {
    "objectID": "labs/lab1/lab1.html#lab-1-fpga-and-mcu-setup-and-testing",
    "href": "labs/lab1/lab1.html#lab-1-fpga-and-mcu-setup-and-testing",
    "title": "E155 Portfolio",
    "section": "",
    "text": "In this lab, a design was implemented on the FPGA to demonstrate the functionality of the on-board high-speed oscillator by blinking one of the on-board LEDs. The high speed oscillator was configured at a frequency of 48 MHz and divided down using a counter to achieve a blinking frequency of 2.4 Hz.\nFurthermore, this design used 4 switches as inputs. These switches turned on an on-board LED by acting as a XOR gate and turned on another on-board LED by acting as an AND gate.\nFinally, this design used the same four switches, acting as a four bit binary number, to turn on a seven-segment display to show all hex digits from 0 to F.\n\n\n\n\n\nThis design consists of two lower level modules, which control a seven segment display and on-board LEDs. Both of these modules were called within a top level module.\nThe seven-segment module uses a case statemnt to map 4 bit hex digit inputs to its corresponding seven-segment output. As a result, flipping switches s[3:0] would display the correct hex digits ranging from 0 to F.\nThe LED control module was used to blink on-board LEDs. First, the on-board high speed oscillator (HSOSC) was used to generate a 48 MHz signal. Then, a counter set to 20 million was used to divide the clock signal. As a result, led[2] was toggled on and off at a frequency of 2.4 Hz. The other two LEDs were toggled using switches s[3:0]. The first led, led[0], was turned on by the XOR of s[0] and s[1]. The second led, led[1], was turned on by the AND of s[2] and s[3].\nFinally, the top level design uses the switch inputs s[3:0] to control logic from the seven-segment and led control modules.\n\n\n\nTesting this design was done via simulation and hardware verification.\nFirst, all lower level modules were tested on their own to make sure all possible inputs work. Then, for simulation of the top module I made sure to test all posible inputs for lower level modules to make sure they interacted properly.\nFor hardware verification, I was able to verify that it functioned as expected by visually confirming correct hex digit representation using hardware. I was also able to verify that the LEDs lit up properly with visual confirmation.\n\n\n\n\nThe source code for the project can be found in the associated GitHub repository.\n\n\n(Figure 1: Block Diagram of the Verilog Design)\nThe block diagram in Figure 1 demonstrates the overall architecture of the design. The top-level module, top, includes two submodules: the led control module (led_control) and the seven segment display module (seven_seg).\n\n\n\n(Figure 2: Schematic of physical layout)\nFigure 2 shows the physical layout of the design. The seven-segment display was connected using 162 Ω current-limmiting resistors to ensure the output current was about 8 mA. This was calculated using ohms law. The board is being powered with 3.3 V, and the display LEDs (deep red) have a forward voltage of 2 V. Therefore, (3.3 - 2 V) / 162 Ω is ~ 8 mA.\n\n\n\n\n\n\n(Figure 3: A screenshot of a QuestaSim simulation demonstrating accurate control and behavior of the LEDs.)\n(Figure 4: A screenshot of a QuestaSim simulation demonstrating proper driving of the seven-segment display.)\n(Figure 5: A screenshot of a QuestaSim simulation demonstrating that all sub-modules works together accurately within the top module.)\nThe design met all intended design objectives. Figure 3 shows that the led_control module works as intended. Any red signals are just don’t cares (x’s) for one of the LEDs. Figure 4 shows that the seven_seg module works as intdended and that I’m able to drive a seven-segment display as intended. Finally, Figure 5 shows that the top module works as intended and that it accurately merges all sub-modules. Again, any red signals are just don’t cares (x’s) from one of the LEDs.\n\n\n\nHardware was also tested via visual confirmation of the on-board LEDs and the seven-segment display lighting up as intetned when switches were flipped in different configurations.\n\n\n\n\nThe design succesfully blinked an on-board LED at 2.4 Hz, toggled on-board LED’s based on XOR and AND gate behavior, and displayed hex digits from 0 to F on a seven-segment display. I spent a total of 15 hours on this lab.\n\n\n\nFor the following AI Prototype, I will be using ChatGPT.\n\n\nWrite SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.\n\n\n\n// Blink an LED at 2 Hz using the internal HFOSC of the UP5K\nmodule top (\n    output logic led   // drive LED pin\n);\n\n    // Internal oscillator (HFOSC) primitive\n    logic clk_hf, clk_en;\n\n    // Lattice UP5K HFOSC instantiation\n    // CLKHF_DIV: \"0b00\" = 48 MHz, \"0b01\" = 24 MHz, \"0b10\" = 12 MHz\n    // Here we choose 12 MHz to make the divider smaller.\n    HSOSC #(\n        .CLKHF_DIV(\"0b10\")  // 12 MHz\n    ) u_hfosc (\n        .CLKHFPU(1'b1),     // power up\n        .CLKHFEN(1'b1),     // enable\n        .CLKHF(clk_hf)      // clock output\n    );\n\n    // Parameters for blink frequency\n    localparam int CLK_FREQ_HZ = 12_000_000;   // HFOSC = 12 MHz\n    localparam int BLINK_HZ    = 2;            // desired blink rate\n    localparam int HALF_PERIOD = CLK_FREQ_HZ / (2 * BLINK_HZ);\n\n    // Counter for frequency division\n    logic [$clog2(HALF_PERIOD)-1:0] counter;\n\n    // LED toggle logic\n    always_ff @(posedge clk_hf) begin\n        if (counter == HALF_PERIOD-1) begin\n            counter &lt;= '0;\n            led &lt;= ~led;\n        end else begin\n            counter &lt;= counter + 1;\n        end\n    end\n\nendmodule\n\n\n\nI think the quality of the output is really high because it produced very clean and readable code. I was mostly able to follow the code that was generated, however, it used syntax such as localparam and $clog2 that was new to me. Surprisingly, the LLM-generated code synthesized first round. I think this was largely due to the prompt that it was fed. Thus when using LLMs in my workflow I will make sure to be as descriptive as possible. Next time however, I will make sure to ask about specifc syntax that it’s using that I am not familiar with."
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "In this lab, we learned how to use time multiplexing to make efficient used of the I/O pins on our FPGA. We used time multiplexing to drive two seven-segment displays with a single set of FPGA I/O pins. We also built transistor circuits to drive large currents from FPGA pins.\n\n\n\n\n\nThis design consists of four lower level modules, which use time multiplexing to control two seven-segment displays with two four-bit switch inputs. Additionally, the switch inputs are added together and their sum is displayed on five LEDs (off-board) to represent a five-bit binary number.\nThe clock division was achieved by using the on-board high-speed oscillator (HSOSC), which generated a 24 MHz clock signal. Then, a counter was used to divide this frequency down to ~60 Hz. After each clock cycle, the seven-segment displays were toggled. Thus, I divided down to a 60 Hz display rate, since it would be fast enough to appear continuous/smooth to the human eye.\nThe switch mux was responsible for selecting the right set of switch inputs based on the enable signal (seven_seg_en), to drive the correct seven segment display. The display_gate module also used the enable signal, but tpo determine which display to turn on.\nFinally, the seven_seg module took in a four-bit switch input and determined the correct seven-segment encoding to diplay the appropraiet hex digit. The input_sum module diplayed the sum of both four-bit switch inputs as a five-bit binary number on five LEDs.\n\n\n\nTesting this design was done via simulation and hardware verification.\nFirst all lower level modules were tested on their own to make sure all possible inputs worked. Then, for simulation of the top module, different clock divider logic was used because the Questa simulator can’t interpret HSOSC. Thus, this simulation ensured the correct toggling of the seven-segment enable signal, correct multiplexing of switch inputs, accurate seven-segment encodings, and correct sum results from switch input addition. The top module only tested a few cases, since every case was exhausted in the lower level module testbenches.\n\n\n\n\nThe source code for the project can be found in the associated GitHub repository.\n\n\n(Figure 1: Block Diagram of the Verilog Design)\nThe block diagram in Figure 1 demonstrates the overall architecture of the design. The top-level module, top, includes four submodules: the switch mux module (switch_mux), the display gate module (display_gate), the seven segment display module (seven_seg), and the input sum module (input_sum). It also contains logic for the the clock divider which toggles the seven_segment displays at our desired frequency (~60 Hz).\n\n\n\n(Figure 2: Schematic of physical layout)\nFigure 2 shows the physical layout of the design. The anodes of seven-segment display were connected using 330 Ω current-limmiting resistors and a 2N3906 PNP transitor to ensure the output current was less than 8 mA. The LEDs of the seven-segment display were connected using 1k Ω resitors, and the off-board LEDs displaying the sum of the switch inputs were connected using 560 Ω resistors.\n\n\n\nAccording, to the ice40 datasheet, on section 4.17 it says the I/O pins are rated for 8 mA. Thus, I chose 330 Ω resistos for the transistor circuit based on the following calculations:\n\\[\nV = 3.3 - V_f = 3.3 - 0.7 = 2.6 \\, \\text{V}\n\\]\n\\[\nV = IR \\quad \\Rightarrow \\quad R = \\frac{V}{I} = \\frac{2.6}{0.008} = 325 \\, \\Omega\n\\]\nFor the seven-segment display LEDs, I used 1 kΩ resistors based on the following equation:\n\\[\nV = 3.3 - V_f - V{CE(sat)} = 3.3 - 2 - 0.25 = 1.05 \\, \\text{V}\n\\]\n\\[\nV = IR \\quad \\Rightarrow \\quad I = \\frac{V}{R} = \\frac{1.05}{1000} = 1.05 \\, mA\n\\]\nI didn’t want the LEDs on the display to run too hot or be too bright, so I just used 1 kΩ resistors resulting in a current of 1.3 mA. Finally, I used 560 Ω resisots for the off-board LEDs based on the following equations:\n\\[\nV = 3.3 - V_f = 3.3 - 1.7 = 1.6 \\, \\text{V}\n\\]\n\\[\nV = IR \\quad \\Rightarrow \\quad R = \\frac{V}{I} = \\frac{1.6}{0.02} = 80 \\, \\Omega\n\\]\n\n\n\n\n\n\n(Figure 3: A screenshot of a QuestaSim simulation demonstrating both seven-segment displays toggle appropriately.)\n(Figure 4: A zoomed in screenshot of a QuestaSim simulation demonstrating the both four-bit inputs sum accurately.)\n(Figure 5: A zoomed out screenshot of a QuestaSim simulation demonstrating the both four-bit inputs sum accurately.)\n(Figure 6: A zoomed in screenshot of a QuestaSim simulation demonstrating accurate switching between both four-bit inputs.)\n(Figure 7: A zoomed out screenshot of a QuestaSim simulation demonstrating accurate switching between both four-bit inputs.)\n(Figure 8: A screenshot of a QuestaSim simulation demonstrating that all sub-module work together accurately to implement time multiplexing for a dual seven-segment display.)\nThe design met all intended design objectives. Figure 3 shows that the display_gate module works and that both seven segment displays turn on appropriately. Figures 4 and 5 show that the input_sum module works as intended, and that the correct sum is calculated by adding both four-bit switch inputs. Figures 6 and 7 show that the switch_mux module works and that it can switch between different four-bit inputs accurately. Finally, Figure 8 shows that the top module works as intended and that it accurately merges all sub-modules.\n\n\n\nHardware was also tested to ensure that there was no noticible flickering, both sets of switch inputs could drive separate seven-segment displays without bleeding, and to ensure that LEDs lit up appropriately to display the sum of the inputs as a five-bit binary number.\n\n\n\n\nThe design succesfully implemented time multiplexing to drive two seven-segment displays with a single set of FPGA I/O pins. There was no flickering or bleeding from the dual seven-segment display. I spent a total of 15 hours on this lab.\n\n\n\nFor the following AI Prototype, I will be using ChatGPT.\n\n\nWrite SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits. Use the seven segment decoder and oscillator provided in the attached files.\n\n\n\nmodule two_digit_display (\n    input  logic       clk,        // main clock input\n    input  logic [3:0] in0,        // first 4-bit input\n    input  logic [3:0] in1,        // second 4-bit input\n    output logic [6:0] seg,        // seven segment outputs (shared)\n    output logic [1:0] an          // common anode control (active low if common anode)\n);\n\n    // Internal signals\n    logic mux_sel;        // toggles between digits\n    logic [3:0] nibble;   // selected input bits\n    logic slow_clk;       // divided clock from oscillator\n\n    // Instantiate oscillator / clock divider (from led_control.sv)\n    oscillator u_divider (\n        .clk_in (clk),\n        .clk_out(slow_clk)\n    );\n\n    // Toggle mux_sel on slow clock\n    always_ff @(posedge slow_clk) begin\n        mux_sel &lt;= ~mux_sel;\n    end\n\n    // Select between input sets\n    always_comb begin\n        if (mux_sel == 1'b0) begin\n            nibble = in0;\n            an     = 2'b10;  // enable digit0, disable digit1\n        end else begin\n            nibble = in1;\n            an     = 2'b01;  // enable digit1, disable digit0\n        end\n    end\n\n    // Instantiate seven segment decoder (from seven_seg.sv)\n    seven_seg u_decoder (\n        .bin  (nibble),\n        .seg  (seg)\n    );\n\nendmodule\n\n\n\nI provided my seven_seg and led_control modules from lab 1 and it synthesized first try. I think the quality of the output is really high because it produced very clean and readable code. I was mostly able to follow the code that was generated, however, it used weird variable names such as nibble, which I didn’t understand. The way that it grabbed the oscillator from my led_control module was also weird. I think the code synthesized first try largely due to the prompt and supporting files that it was fed. Thus, when using LLMs in my workflow I will make sure to be as descriptive with prompts as possible, so that it can generate code with behavior that I expect. Next time however, I will make sure to ask about anything in the code that doesn’t make sense to me."
  },
  {
    "objectID": "labs/lab2/lab2.html#lab-2-multiplexed-7-segment-display",
    "href": "labs/lab2/lab2.html#lab-2-multiplexed-7-segment-display",
    "title": "E155 Portfolio",
    "section": "",
    "text": "In this lab, we learned how to use time multiplexing to make efficient used of the I/O pins on our FPGA. We used time multiplexing to drive two seven-segment displays with a single set of FPGA I/O pins. We also built transistor circuits to drive large currents from FPGA pins.\n\n\n\n\n\nThis design consists of four lower level modules, which use time multiplexing to control two seven-segment displays with two four-bit switch inputs. Additionally, the switch inputs are added together and their sum is displayed on five LEDs (off-board) to represent a five-bit binary number.\nThe clock division was achieved by using the on-board high-speed oscillator (HSOSC), which generated a 24 MHz clock signal. Then, a counter was used to divide this frequency down to ~60 Hz. After each clock cycle, the seven-segment displays were toggled. Thus, I divided down to a 60 Hz display rate, since it would be fast enough to appear continuous/smooth to the human eye.\nThe switch mux was responsible for selecting the right set of switch inputs based on the enable signal (seven_seg_en), to drive the correct seven segment display. The display_gate module also used the enable signal, but tpo determine which display to turn on.\nFinally, the seven_seg module took in a four-bit switch input and determined the correct seven-segment encoding to diplay the appropraiet hex digit. The input_sum module diplayed the sum of both four-bit switch inputs as a five-bit binary number on five LEDs.\n\n\n\nTesting this design was done via simulation and hardware verification.\nFirst all lower level modules were tested on their own to make sure all possible inputs worked. Then, for simulation of the top module, different clock divider logic was used because the Questa simulator can’t interpret HSOSC. Thus, this simulation ensured the correct toggling of the seven-segment enable signal, correct multiplexing of switch inputs, accurate seven-segment encodings, and correct sum results from switch input addition. The top module only tested a few cases, since every case was exhausted in the lower level module testbenches.\n\n\n\n\nThe source code for the project can be found in the associated GitHub repository.\n\n\n(Figure 1: Block Diagram of the Verilog Design)\nThe block diagram in Figure 1 demonstrates the overall architecture of the design. The top-level module, top, includes four submodules: the switch mux module (switch_mux), the display gate module (display_gate), the seven segment display module (seven_seg), and the input sum module (input_sum). It also contains logic for the the clock divider which toggles the seven_segment displays at our desired frequency (~60 Hz).\n\n\n\n(Figure 2: Schematic of physical layout)\nFigure 2 shows the physical layout of the design. The anodes of seven-segment display were connected using 330 Ω current-limmiting resistors and a 2N3906 PNP transitor to ensure the output current was less than 8 mA. The LEDs of the seven-segment display were connected using 1k Ω resitors, and the off-board LEDs displaying the sum of the switch inputs were connected using 560 Ω resistors.\n\n\n\nAccording, to the ice40 datasheet, on section 4.17 it says the I/O pins are rated for 8 mA. Thus, I chose 330 Ω resistos for the transistor circuit based on the following calculations:\n\\[\nV = 3.3 - V_f = 3.3 - 0.7 = 2.6 \\, \\text{V}\n\\]\n\\[\nV = IR \\quad \\Rightarrow \\quad R = \\frac{V}{I} = \\frac{2.6}{0.008} = 325 \\, \\Omega\n\\]\nFor the seven-segment display LEDs, I used 1 kΩ resistors based on the following equation:\n\\[\nV = 3.3 - V_f - V{CE(sat)} = 3.3 - 2 - 0.25 = 1.05 \\, \\text{V}\n\\]\n\\[\nV = IR \\quad \\Rightarrow \\quad I = \\frac{V}{R} = \\frac{1.05}{1000} = 1.05 \\, mA\n\\]\nI didn’t want the LEDs on the display to run too hot or be too bright, so I just used 1 kΩ resistors resulting in a current of 1.3 mA. Finally, I used 560 Ω resisots for the off-board LEDs based on the following equations:\n\\[\nV = 3.3 - V_f = 3.3 - 1.7 = 1.6 \\, \\text{V}\n\\]\n\\[\nV = IR \\quad \\Rightarrow \\quad R = \\frac{V}{I} = \\frac{1.6}{0.02} = 80 \\, \\Omega\n\\]\n\n\n\n\n\n\n(Figure 3: A screenshot of a QuestaSim simulation demonstrating both seven-segment displays toggle appropriately.)\n(Figure 4: A zoomed in screenshot of a QuestaSim simulation demonstrating the both four-bit inputs sum accurately.)\n(Figure 5: A zoomed out screenshot of a QuestaSim simulation demonstrating the both four-bit inputs sum accurately.)\n(Figure 6: A zoomed in screenshot of a QuestaSim simulation demonstrating accurate switching between both four-bit inputs.)\n(Figure 7: A zoomed out screenshot of a QuestaSim simulation demonstrating accurate switching between both four-bit inputs.)\n(Figure 8: A screenshot of a QuestaSim simulation demonstrating that all sub-module work together accurately to implement time multiplexing for a dual seven-segment display.)\nThe design met all intended design objectives. Figure 3 shows that the display_gate module works and that both seven segment displays turn on appropriately. Figures 4 and 5 show that the input_sum module works as intended, and that the correct sum is calculated by adding both four-bit switch inputs. Figures 6 and 7 show that the switch_mux module works and that it can switch between different four-bit inputs accurately. Finally, Figure 8 shows that the top module works as intended and that it accurately merges all sub-modules.\n\n\n\nHardware was also tested to ensure that there was no noticible flickering, both sets of switch inputs could drive separate seven-segment displays without bleeding, and to ensure that LEDs lit up appropriately to display the sum of the inputs as a five-bit binary number.\n\n\n\n\nThe design succesfully implemented time multiplexing to drive two seven-segment displays with a single set of FPGA I/O pins. There was no flickering or bleeding from the dual seven-segment display. I spent a total of 15 hours on this lab.\n\n\n\nFor the following AI Prototype, I will be using ChatGPT.\n\n\nWrite SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits. Use the seven segment decoder and oscillator provided in the attached files.\n\n\n\nmodule two_digit_display (\n    input  logic       clk,        // main clock input\n    input  logic [3:0] in0,        // first 4-bit input\n    input  logic [3:0] in1,        // second 4-bit input\n    output logic [6:0] seg,        // seven segment outputs (shared)\n    output logic [1:0] an          // common anode control (active low if common anode)\n);\n\n    // Internal signals\n    logic mux_sel;        // toggles between digits\n    logic [3:0] nibble;   // selected input bits\n    logic slow_clk;       // divided clock from oscillator\n\n    // Instantiate oscillator / clock divider (from led_control.sv)\n    oscillator u_divider (\n        .clk_in (clk),\n        .clk_out(slow_clk)\n    );\n\n    // Toggle mux_sel on slow clock\n    always_ff @(posedge slow_clk) begin\n        mux_sel &lt;= ~mux_sel;\n    end\n\n    // Select between input sets\n    always_comb begin\n        if (mux_sel == 1'b0) begin\n            nibble = in0;\n            an     = 2'b10;  // enable digit0, disable digit1\n        end else begin\n            nibble = in1;\n            an     = 2'b01;  // enable digit1, disable digit0\n        end\n    end\n\n    // Instantiate seven segment decoder (from seven_seg.sv)\n    seven_seg u_decoder (\n        .bin  (nibble),\n        .seg  (seg)\n    );\n\nendmodule\n\n\n\nI provided my seven_seg and led_control modules from lab 1 and it synthesized first try. I think the quality of the output is really high because it produced very clean and readable code. I was mostly able to follow the code that was generated, however, it used weird variable names such as nibble, which I didn’t understand. The way that it grabbed the oscillator from my led_control module was also weird. I think the code synthesized first try largely due to the prompt and supporting files that it was fed. Thus, when using LLMs in my workflow I will make sure to be as descriptive with prompts as possible, so that it can generate code with behavior that I expect. Next time however, I will make sure to ask about anything in the code that doesn’t make sense to me."
  },
  {
    "objectID": "labs/lab4/lab4.html",
    "href": "labs/lab4/lab4.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "In this lab, I used an MCU to play music. I used timers to generate square waves by toggling a GPIO pin at specific frequencies for specified periods of time.\n\n\n\n\n\nThis design uses two timers to handle setting new frequencies and to specify duration time separately. The TIM15 timer is used to handle setting frequencies by setting it to PWM mode. The TIM16 timer is used to handle the duration of each note by setting it in upcounting mode. Finally, this design uses the PLL clock at 80 MHz, thus the prescaler and auto reload registers are adjusted accordingly to ensure an accurate frequency is being outputted.\nAs far as hardware goes, the design uses an LM386 audio amplifier, an op-amp circuit with a potentiometer for volume control, and an 8 Ω speaker.\n\n\n\nTesting this design was done via hardware verification. The speaker was plugged into the circuit, and I ensured the correct notes were playing from the speaker.\n\n\n\n\nThe source code for the project can be found in the associated GitHub repository.\n\n\n(Figure 1: Schematic of physical layout)\nFigure 1 shows the physical layout of the design. The MCU was connected to an op-amp circuit which drove an 8 Ω speaker to play music.\n\n\n\nAll necessary calculations to get accurate duration time and frequency were done using the following equation. PSC and ARR have to be within 16 bits (2^16). For both timers, I hard set PSC, while ARR was dynamic.\n\\[\nf_{\\text{out}} = \\frac{f_{\\text{CLK}}}{(PSC+1)(ARR+1)}\n\\]\nRearanging to solve for ARR: \\[\nARR = \\frac{f_{\\text{CLK}}}{(PSC+1)(f_{\\text{out}})} - 1\n\\]\n\n\nMinimum frequency when ARR = 2^16 -&gt; 203.45 Hz Maximum frequency when ARR = 0 -&gt; 13.3 MHz\n\n\n\nMinimum duration when ARR = 0 -&gt; 8.8 ns Maximum duration when ARR = 2^16 -&gt; 574.3 ms\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\nPSC\nARR\nfrequency_expected [Hz]\nactual frequency [Hz]\nerror [%]\n\n\n\n\nA3\n5\n60605\n220.0\n220.00022\n1.000001e-06\n\n\nA3 sharp / B3 flat\n5\n57199\n233.1\n233.1002331\n1.000001e-06\n\n\nB3\n5\n54001\n246.9\n246.9044356\n1.796532275e-05\n\n\nC4 (middle C)\n5\n50967\n261.6\n261.602051\n7.840061466e-06\n\n\nC4 sharp / D4 flat\n5\n48099\n277.2\n277.2002772\n1.000001e-06\n\n\nD4\n5\n45396\n293.7\n293.7051641\n1.758280915e-05\n\n\nD4 sharp / E4 flat\n5\n42857\n311.1\n311.104889\n1.571524696e-05\n\n\nE4\n5\n40452\n329.6\n329.6006065\n1.840003386e-06\n\n\nF4\n5\n38181\n349.2\n349.2046863\n1.34201801e-05\n\n\nF4 sharp / G4 flat\n5\n36035\n370.0\n370.00037\n1.000001e-06\n\n\nG4\n5\n34012\n392.0\n392.0069777\n1.780031685e-05\n\n\nG4 sharp / A4 flat\n5\n32104\n415.3\n415.3039506\n9.512590488e-06\n\n\nA4\n5\n30302\n440.0\n440.00044\n1.000001e-06\n\n\nA4 sharp / B4 flat\n5\n28599\n466.2\n466.2004662\n1.000001e-06\n\n\nB4\n5\n26995\n493.9\n493.9003309\n6.700004489e-07\n\n\nC5\n5\n25478\n523.3\n523.3067755\n1.294766764e-05\n\n\nC5 sharp / D5 flat\n5\n24049\n554.4\n554.4005544\n1.000001e-06\n\n\nD5\n5\n22701\n587.3\n587.3197662\n3.36561327e-05\n\n\nD5 sharp / E5 flat\n5\n21428\n622.2\n622.209778\n1.571524696e-05\n\n\nE5\n5\n20225\n659.2\n659.2175088\n2.656070545e-05\n\n\nF5\n5\n19090\n698.4\n698.4093727\n1.34201801e-05\n\n\nF5 sharp / G5 flat\n5\n17995\n740.9\n740.9053864\n7.270052853e-06\n\n\nG5\n5\n17005\n784.0\n784.0370065\n4.720222795e-05\n\n\nG5 sharp / A5 flat\n5\n16051\n830.6\n830.6337736\n4.06616533e-05\n\n\nA5\n5\n15150\n880.0\n880.029921\n3.400115604e-05\n\n\nMinimum Frequency\n5\n65536\n-\n203.4474165\n-\n\n\nMaximum Frequency\n5\n0\n-\n13333333.33\n-\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote Type\nPSC\nARR\nduration_expected [ms]\nactual duration [ms]\nerror [%]\n\n\n\n\nWhole\n700\n57060\n500.0\n499.9970125\n5.975e-06\n\n\nHalf\n700\n28529\n250.0\n249.994125\n2.35e-05\n\n\nQuarter\n700\n14264\n125.0\n124.9970625\n2.35e-05\n\n\nEighth\n700\n7131\n62.5\n62.49415\n9.36e-05\n\n\nSixteenth\n700\n3565\n31.25\n31.247075\n9.36e-05\n\n\nMinimum Duration\n700\n0\n-\n0.0087625\n-\n\n\nMaximum Duration\n700\n65536\n-\n574.2679625\n-\n\n\n\n\n\n\n\n\n\n\nThe correct notes were being play from the speaker and volume was controllable using a potentiometer. First, I was able to play Für Elise, then I played Twinkle Twinkle Little Star.\n\n\n\n\n\n\n\n\nThis design sucessfully used timers and toggled a GPIO pin on an MCU to play music. Additionally, volume was controllable by adjusting a potentiometer. I spent a total of 25 hours on this lab, mostly because I was running into a lot of issues with SEGGER on my laptop.\n\n\n\nFor the following AI Prototype, I will be using ChatGPT.\n\n\nWhat timers should I use on the STM32L432KC to generate frequencies ranging from 220Hz to 1kHz? What’s the best choice of timer if I want to easily connect it to a GPIO pin? What formulae are relevant, and what registers need to be set to configure them properly?\n\n\n\nAccording to ChatGPT, the best timer to use is TIM2 because it has “large flexibility” with “less math headache”. ChatGPT did also say TIM15-TIM17 are also viable options becuase they are lightweight (only 16-bits) and they connect to GPIO alternate functions. Furthmore ChatGPT provided the equation for how PWM frequency should be set which I found to be accurate.\n\n\n\nThe code generated for these prompts can be found here.\n\n\n\nI think the quality of the output was extremely highly, especially given the fact that it had no reference manual for the MCU as context at first. I think the reference manual would help with actually producing more functional code, but for just getting the high (and even some low) level ideas, ChatGPT seems to do good without. The speed and quality of the LLM is much faster than my own read of the reference manual. I can see how it can point me torwards the right sections when Ctrl+F can’t, but I would still have to find the actual pages myself. The LLM didn’t generate any code for me, but after I prompted it to do so, it opted to use timer 2. I found this choice bizarre because it is somehow “easier” math-wise. Furthermore, ChatGPT even acknowledge the fact that other timers are more light weight, which in my opinion would be more practical in the real world. Finally, I think that LLM’s are significantly better at document searching and generating these higher level ideas that acting as an HDL generator as demonstrated in previous prototypes. I think this is mostly the case because I feel like LLM’s are generally better at searching for information than generating code and creating logic."
  },
  {
    "objectID": "labs/lab4/lab4.html#lab-4-digital-audio",
    "href": "labs/lab4/lab4.html#lab-4-digital-audio",
    "title": "E155 Portfolio",
    "section": "",
    "text": "In this lab, I used an MCU to play music. I used timers to generate square waves by toggling a GPIO pin at specific frequencies for specified periods of time.\n\n\n\n\n\nThis design uses two timers to handle setting new frequencies and to specify duration time separately. The TIM15 timer is used to handle setting frequencies by setting it to PWM mode. The TIM16 timer is used to handle the duration of each note by setting it in upcounting mode. Finally, this design uses the PLL clock at 80 MHz, thus the prescaler and auto reload registers are adjusted accordingly to ensure an accurate frequency is being outputted.\nAs far as hardware goes, the design uses an LM386 audio amplifier, an op-amp circuit with a potentiometer for volume control, and an 8 Ω speaker.\n\n\n\nTesting this design was done via hardware verification. The speaker was plugged into the circuit, and I ensured the correct notes were playing from the speaker.\n\n\n\n\nThe source code for the project can be found in the associated GitHub repository.\n\n\n(Figure 1: Schematic of physical layout)\nFigure 1 shows the physical layout of the design. The MCU was connected to an op-amp circuit which drove an 8 Ω speaker to play music.\n\n\n\nAll necessary calculations to get accurate duration time and frequency were done using the following equation. PSC and ARR have to be within 16 bits (2^16). For both timers, I hard set PSC, while ARR was dynamic.\n\\[\nf_{\\text{out}} = \\frac{f_{\\text{CLK}}}{(PSC+1)(ARR+1)}\n\\]\nRearanging to solve for ARR: \\[\nARR = \\frac{f_{\\text{CLK}}}{(PSC+1)(f_{\\text{out}})} - 1\n\\]\n\n\nMinimum frequency when ARR = 2^16 -&gt; 203.45 Hz Maximum frequency when ARR = 0 -&gt; 13.3 MHz\n\n\n\nMinimum duration when ARR = 0 -&gt; 8.8 ns Maximum duration when ARR = 2^16 -&gt; 574.3 ms\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\nPSC\nARR\nfrequency_expected [Hz]\nactual frequency [Hz]\nerror [%]\n\n\n\n\nA3\n5\n60605\n220.0\n220.00022\n1.000001e-06\n\n\nA3 sharp / B3 flat\n5\n57199\n233.1\n233.1002331\n1.000001e-06\n\n\nB3\n5\n54001\n246.9\n246.9044356\n1.796532275e-05\n\n\nC4 (middle C)\n5\n50967\n261.6\n261.602051\n7.840061466e-06\n\n\nC4 sharp / D4 flat\n5\n48099\n277.2\n277.2002772\n1.000001e-06\n\n\nD4\n5\n45396\n293.7\n293.7051641\n1.758280915e-05\n\n\nD4 sharp / E4 flat\n5\n42857\n311.1\n311.104889\n1.571524696e-05\n\n\nE4\n5\n40452\n329.6\n329.6006065\n1.840003386e-06\n\n\nF4\n5\n38181\n349.2\n349.2046863\n1.34201801e-05\n\n\nF4 sharp / G4 flat\n5\n36035\n370.0\n370.00037\n1.000001e-06\n\n\nG4\n5\n34012\n392.0\n392.0069777\n1.780031685e-05\n\n\nG4 sharp / A4 flat\n5\n32104\n415.3\n415.3039506\n9.512590488e-06\n\n\nA4\n5\n30302\n440.0\n440.00044\n1.000001e-06\n\n\nA4 sharp / B4 flat\n5\n28599\n466.2\n466.2004662\n1.000001e-06\n\n\nB4\n5\n26995\n493.9\n493.9003309\n6.700004489e-07\n\n\nC5\n5\n25478\n523.3\n523.3067755\n1.294766764e-05\n\n\nC5 sharp / D5 flat\n5\n24049\n554.4\n554.4005544\n1.000001e-06\n\n\nD5\n5\n22701\n587.3\n587.3197662\n3.36561327e-05\n\n\nD5 sharp / E5 flat\n5\n21428\n622.2\n622.209778\n1.571524696e-05\n\n\nE5\n5\n20225\n659.2\n659.2175088\n2.656070545e-05\n\n\nF5\n5\n19090\n698.4\n698.4093727\n1.34201801e-05\n\n\nF5 sharp / G5 flat\n5\n17995\n740.9\n740.9053864\n7.270052853e-06\n\n\nG5\n5\n17005\n784.0\n784.0370065\n4.720222795e-05\n\n\nG5 sharp / A5 flat\n5\n16051\n830.6\n830.6337736\n4.06616533e-05\n\n\nA5\n5\n15150\n880.0\n880.029921\n3.400115604e-05\n\n\nMinimum Frequency\n5\n65536\n-\n203.4474165\n-\n\n\nMaximum Frequency\n5\n0\n-\n13333333.33\n-\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote Type\nPSC\nARR\nduration_expected [ms]\nactual duration [ms]\nerror [%]\n\n\n\n\nWhole\n700\n57060\n500.0\n499.9970125\n5.975e-06\n\n\nHalf\n700\n28529\n250.0\n249.994125\n2.35e-05\n\n\nQuarter\n700\n14264\n125.0\n124.9970625\n2.35e-05\n\n\nEighth\n700\n7131\n62.5\n62.49415\n9.36e-05\n\n\nSixteenth\n700\n3565\n31.25\n31.247075\n9.36e-05\n\n\nMinimum Duration\n700\n0\n-\n0.0087625\n-\n\n\nMaximum Duration\n700\n65536\n-\n574.2679625\n-\n\n\n\n\n\n\n\n\n\n\nThe correct notes were being play from the speaker and volume was controllable using a potentiometer. First, I was able to play Für Elise, then I played Twinkle Twinkle Little Star.\n\n\n\n\n\n\n\n\nThis design sucessfully used timers and toggled a GPIO pin on an MCU to play music. Additionally, volume was controllable by adjusting a potentiometer. I spent a total of 25 hours on this lab, mostly because I was running into a lot of issues with SEGGER on my laptop.\n\n\n\nFor the following AI Prototype, I will be using ChatGPT.\n\n\nWhat timers should I use on the STM32L432KC to generate frequencies ranging from 220Hz to 1kHz? What’s the best choice of timer if I want to easily connect it to a GPIO pin? What formulae are relevant, and what registers need to be set to configure them properly?\n\n\n\nAccording to ChatGPT, the best timer to use is TIM2 because it has “large flexibility” with “less math headache”. ChatGPT did also say TIM15-TIM17 are also viable options becuase they are lightweight (only 16-bits) and they connect to GPIO alternate functions. Furthmore ChatGPT provided the equation for how PWM frequency should be set which I found to be accurate.\n\n\n\nThe code generated for these prompts can be found here.\n\n\n\nI think the quality of the output was extremely highly, especially given the fact that it had no reference manual for the MCU as context at first. I think the reference manual would help with actually producing more functional code, but for just getting the high (and even some low) level ideas, ChatGPT seems to do good without. The speed and quality of the LLM is much faster than my own read of the reference manual. I can see how it can point me torwards the right sections when Ctrl+F can’t, but I would still have to find the actual pages myself. The LLM didn’t generate any code for me, but after I prompted it to do so, it opted to use timer 2. I found this choice bizarre because it is somehow “easier” math-wise. Furthermore, ChatGPT even acknowledge the fact that other timers are more light weight, which in my opinion would be more practical in the real world. Finally, I think that LLM’s are significantly better at document searching and generating these higher level ideas that acting as an HDL generator as demonstrated in previous prototypes. I think this is mostly the case because I feel like LLM’s are generally better at searching for information than generating code and creating logic."
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "Initial Reflections Post",
    "section": "",
    "text": "My main goal for this semester in MicroP’s is to learn new skills that will be useful to me as an electrical engineer. I haven’t had much experience working with embedded systems, so I would love to become more comfortable in this realm. I really enjoy music, so for my final project I think working on something audio related would be really fun."
  },
  {
    "objectID": "labs.html#lab-2-multiplexed-7-segment-display",
    "href": "labs.html#lab-2-multiplexed-7-segment-display",
    "title": "E155 Labs",
    "section": "Lab 2: Multiplexed 7-Segment Display",
    "text": "Lab 2: Multiplexed 7-Segment Display"
  },
  {
    "objectID": "labs.html#lab-3-keypad-scanner",
    "href": "labs.html#lab-3-keypad-scanner",
    "title": "E155 Labs",
    "section": "Lab 3: Keypad Scanner",
    "text": "Lab 3: Keypad Scanner"
  },
  {
    "objectID": "labs.html#lab-4-digital-audio",
    "href": "labs.html#lab-4-digital-audio",
    "title": "E155 Labs",
    "section": "Lab 4: Digital Audio",
    "text": "Lab 4: Digital Audio"
  },
  {
    "objectID": "labs.html#lab-5-interrupts",
    "href": "labs.html#lab-5-interrupts",
    "title": "E155 Labs",
    "section": "Lab 5: Interrupts",
    "text": "Lab 5: Interrupts"
  },
  {
    "objectID": "labs.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "href": "labs.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "title": "E155 Labs",
    "section": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "text": "Lab 6: The Internet of Things and Serial Peripheral Interface"
  },
  {
    "objectID": "labs.html#lab-7-the-advanced-encryption-standard",
    "href": "labs.html#lab-7-the-advanced-encryption-standard",
    "title": "E155 Labs",
    "section": "Lab 7: The Advanced Encryption Standard",
    "text": "Lab 7: The Advanced Encryption Standard"
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "E155 Resources",
    "section": "",
    "text": "E155 Course Website"
  }
]